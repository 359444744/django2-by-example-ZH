<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="css/normalize.min.css">
    <link rel="stylesheet" href="css/base.css">
    <title>第八章 管理支付与订单</title>

</head>
<body>
<h1 id="top"><b>管理支付与订单</b></h1>
<p>上一章制作了一个带有商品品类展示和购物车功能的电商网站雏形，同时也学到了如何使用Celery给项目增加异步任务。本章将学习为网站集成支付网关以让用户通过信用卡付款，还将为管理后台扩展两项功能：将数据导出为CSV以及生成PDF发票。</p>
<p>本章的主要内容有：</p>
<ul>
    <li>集成支付网关到项目中</li>
    <li>将订单数据导出成CSV文件</li>
    <li>为管理后台创建自定义视图</li>
    <li>动态生成PDF发票</li>
</ul>
<h2 id="c8-1"><span class="title">1</span>集成支付网关</h2>

<p>支付网关是一种处理在线支付的网站或者程序，使用支付网关，就可以管理用户的订单，然后将支付过程交给一个可信赖且安全的第三方，而无需在我们自己的站点上处理支付信息。</p>
<p>支付网关有很多可供选择，我们将要集成的是叫做"Braintree"的支付网关。Braintree使用较为广泛，是Uber和Airbnb的支付服务提供商。Braintree提供了一套API用于支持信用卡，PayPal，Android Pay和Apple Pay等支付方式，官方网站在<a
        href="https://www.braintreepayments.com/" target="_blank">https://www.braintreepayments.com/</a>。</p>
<p>Braintree提供了很多集成的方法，最简单的集成方式就是Drop-in集成，包含一个预先建立好的支付表单。但是为了自定义一些支付过程中的内容，这里选择使用高级的<em>Hosted Field</em>（字段托管）方式进行集成。在<a
        href="https://developers.braintreepayments.com/guides/hosted-fields/overview/javascript/v3" target="_blank">https://developers.braintreepayments.com/guides/hosted-fields/overview/javascript/v3</a>可以看到详细的帮助文档。</p>
<p>支付表单中包含的信用卡号，CVV码，过期日期等信息必须要得到安全处理，Hosted Field集成方式将这些字段展示给用户的时候，在页面中渲染的是一个iframe框架。我们可以来自定义该字段的外观，但必须要遵循<a
        href="https://en.wikipedia.org/wiki/Payment_Card_Industry_Data_Security_Standard" target="_blank">Payment Card Industry (PCI)安全支付</a>的要求。由于可以修改外观，用户并不会注意到页面使用了iframe。</p>
<p class="emp">译者注：原书在这里说的不是很清晰。Hosted Fields的意思是敏感字段由我们页面中的Braintree JavaScript客户端通过Braintree服务器生成并填入到页面中，而不是在模板中直接编写<code>input</code>字段。简单的说就是信用卡等敏感信息的字段是由Braintree托管生成，而不是我们自行编写。</p>
<h3 id="c8-1-1"><span class="title">1.1</span>注册Braintree沙盒测试账户</h3>
<p>需要注册一个Braintree账户。才能使用集成支付功能。我们先注册一个Braintree沙盒账户用于开发和测试。打开<a
        href="https://www.braintreepayments.com/sandbox" target="_blank">https://www.braintreepayments.com/sandbox</a>，如下图所示：</p>
<p><img src="http://img.conyli.cc/django2/C08-01.jpg" alt=""></p>
<p>填写表单创建用户，之后会收到电子邮件验证，验证通过之后在<a href="https://sandbox.braintreegateway.com/login" target="_blank">https://sandbox.braintreegateway.com/login</a>进行登录。可以得到自己的商户ID和私有/公开密钥如下图所示：</p>
<p><img src="http://img.conyli.cc/django2/C08-02.jpg" alt=""></p>
<p>这些信息与使用Braintree API进行验证交易有关，注意保存好私钥，不要泄露给他人。</p>

<h3 id="c8-1-2"><span class="title">1.2</span>安装Braintree的Python模块</h3>
<p>Braintree为Python提供了一个模块操作其API，源代码地址在<a href="https://github.com/braintree/braintree_python" target="_blank">https://github.com/braintree/braintree_python</a>。我们将把这个<code>braintree</code>模块集成到站点中。</p>
<p>使用命令行安装<code>braintree</code>模块：</p>
<pre>
pip install braintree==3.45.0
</pre>
<p>之后在<code>settings.py</code>里配置：</p>
<pre>
# Braintree支付网关设置
BRAINTREE_MERCHANT_ID = 'XXX'  # 商户ID
BRAINTREE_PUBLIC_KEY = 'XXX'  # 公钥
BRAINTREE_PRIVATE_KEY = 'XXX'  # 私钥

from braintree import Configuration, Environment

Configuration.configure(
    Environment.Sandbox,
    BRAINTREE_MERCHANT_ID,
    BRAINTREE_PUBLIC_KEY,
    BRAINTREE_PRIVATE_KEY
)
</pre>
<p>将<code>BRAINTREE_MERCHANT_ID</code>，<code>BRAINTREE_PUBLIC_KEY</code>，<code>BRAINTREE_PRIVATE_KEY</code>的值替换成你自己的实际信息。</p>
<p class="hint">注意此处的设置 <code>Environment.Sandbox,</code>，表示我们当前集成的是沙盒环境。如果站点正式上线并且获取了正式的Braintree账户，必须修改成<code>Environment.Production</code>。Braintree对于正式账号会有新的商户ID和公钥/私钥。</p>
<p>Braintree的基础设置结束了，下一步是将支付网关和支付过程结合起来。</p>

<h3 id="c8-1-3"><span class="title">1.3</span>集成支付网关</h3>
<p>结账过程是这样的：</p>
<ol>
    <li>将商品加入到购物车</li>
    <li>从购物车中选择结账</li>
    <li>输入信用卡信息并且支付</li>
</ol>
<p>针对支付功能，我们建立一个新的应用叫做<code>payment</code>：</p>
<pre>python manage.py startapp payment</pre>

<p>编辑<code>settings.py</code>文件，激活该应用：</p>
<pre>
INSTALLED_APPS = [
    # ...
    <b>'payment.apps.PaymentConfig',</b>
]
</pre>
<p><code>payment</code>现在已经被激活。</p>
<p>客户成功提交订单后，必须将该页面重定向到一个支付过程页面（目前是重定向到一个简单的成功页面）。编辑<code>orders</code>应用中的<code>views.py</code>，增加如下导入：</p>
<pre>
<b>from django.urls import reverse</b>
from django.shortcuts import render, <b>redirect</b>
</pre>
<p>在同一个文件内，将<code>order_create</code>视图的如下部分：</p>
<pre>
# 启动异步任务
order_created.delay(order.id)
return render(request, 'orders/order/created.html', locals())
</pre>
<p>替换成：</p>
<pre>
# 启动异步任务
order_created.delay(order.id)
<b># 在session中加入订单id
request.session['order_id'] = order.id
# 重定向到支付页面
return redirect(reverse('payment:process'))</b>
</pre>
<p>这样修改后，在成功创建订单之后，session中就保存了订单ID的变量<code>order_id</code>，然后用户被重定向至<code>payment:process</code> URL，这个URL稍后会编写。</p>
<p>注意必须为<code>order_created</code>视图启动Celery。</p>
<p>每次我们向Braintree中发送一个交易请求的时候，会生成一个唯一的交易ID号。因此我们在<code>Order</code>模型中增加一个字段用于存储这个交易ID号，这样可以将订单与Braintree交易联系起来。</p>
<p>编辑<code>orders</code>应用的<code>models.py</code>文件，为<code>Order</code>模型新增一行：</p>
<pre>
class Order(models.Model):
    # ...
    <b>braintree_id = models.CharField(max_length=150, blank=True)</b>
</pre>
<p>之后执行数据迁移程序，每一个订单都会保存与其关联的交易ID。目前准备工作都已经做完，剩下就是在支付过程中使用支付网关。</p>

<h4 id="c8-1-3-1"><span class="title">1.3.1</span>使用Hosted Fields进行支付</h4>
<p>Hosted Fields方式允许我们创建自定义的支付表单，使用自定义样式和表现形式。Braintree JavaScript SDK会在页面中动态的添加iframe框体用于展示Host Fields支付字段。当用户提交表单的时候，Hosted Fields会安全地提取用户的信用卡等信息，生成一个特征字符串（tokenize，令牌化）。如果令牌化过程成功，就可以使用这个特征字符串（token），通过视图中的<code>braintree</code>模块发起一个支付申请。</p>
<p>为此需要建立一个支付视图。这个视图的工作流程如下：</p>
<ol>
    <li>用户提交订单时，视图通过<code>braintree</code>模块生成一个token，这个token用于Braintree JavaScript 客户端生成支付表单，并不是最终发送给支付网关的token。为了方便以下把这个token称为临时token，把最终提交给Braintree网站的token叫做交易token。</li>
    <li>视图渲染支付表单所在的模板。页面中的Braintree JavaScript 客户端使用临时token来生成页面中的支付表单。</li>
    <li>用户输入信用卡信息并且提交支付表单后，Braintree JavaScript 客户端会生成交易token，将这个交易token通过<code>POST</code>请求发送到视图</li>
    <li>视图获取交易token之后，通过<code>braintree</code>模块向网站提交交易请求。</li>
</ol>
<p>了解了工作流程之后，来编写相关视图，编辑<code>payment</code>应用中的<code>views.py</code>文件，添加下列代码：</p>
<pre>
import braintree
from django.shortcuts import render, redirect, get_object_or_404
from orders.models import Order

def payment_process(request):
    order_id = request.session.get('order_id')
    order = get_object_or_404(Order, id=order_id)

    if request.method == "POST":
        # 获得交易token
        nonce = request.POST.get('payment_method_nonce', None)
        # 使用交易token和附加信息，创建并提交交易信息
        result = braintree.Transaction.sale(
            {
                'amount': '{:2f}'.format(order.get_total_cost()),
                'payment_method_nonce': nonce,
                'options': {
                    'submit_for_settlement': True,
                }
            }
        )
        if result.is_success:
            # 标记订单状态为已支付
            order.paid = True
            # 保存交易ID
            order.braintree_id = result.transaction.id
            order.save()
            return redirect('payment:done')
        else:
            return redirect('payment:canceled')

    else:
        # 生成临时token交给页面上的JS程序
        client_token = braintree.ClientToken.generate()
        return render(request,
                      'payment/process.html',
                      {'order': order,
                       'client_token': client_token})
</pre>
<p>这个<code>payment_process</code>视图管理支付过程，工作流程如下 ：</p>
<ol>
    <li>从session中取出由<code>order_create</code>视图设置的<code>order_id</code>变量。</li>
    <li>获取<code>Order</code>对象，如果没找到，返回<code>404 Not Found</code>错误</li>
    <li>如果接收到<code>POST</code>请求，获取交易token <code>payment_method_nonce</code>，使用交易token和<code>braintree.Transaction.sale()</code>方法生成新的交易，该方法的几个参数解释如下：<ol>
        <li><code>amount</code>：总收款金额</li>
        <li><code>payment_method_nonce</code>：交易token，由页面中的Braintree JavaScript 客户端生成。</li>
        <li><code>options</code>：其他选项，<code>submit_for_settlement</code>设置为<code>True</code>表示生成交易信息完毕的时候就立刻提交。</li>
    </ol></li>
    <li>如果交易成功，通过设置<code>paid</code>属性为<code>True</code>，将订单标记为已支付，将交易ID存储到<code>braintree_id</code>属性中，之后重定向至<code>payment:done</code>，如果交易失败就重定向至<code>payment:canceled</code>。</li>
    <li>如果视图接收到<code>GET</code>请求，生成临时token交给页面中的Braintree JavaScript 客户端。</li>
</ol>
<p>下边建立支付成功和失败时的处理视图，在<code>payment</code>应用的views.py中添加下列代码：</p>
<pre>
def payment_done(request):
    return render(request, 'payment/done.html')
def payment_canceled(request):
    return render(request, 'payment/canceled.html')
</pre>
<p>然后在<code>payment</code>目录下建立<code>urls.py</code>，为上述视图配置路由：</p>
<pre>
from django.urls import path
from . import views

app_name = 'payment'

urlpatterns = [
    path('process/', views.payment_process, name='process'),
    path('done/', views.payment_done, name='done'),
    path('canceled/', views.payment_canceled, name='canceled'),
]
</pre>
<p>这是支付流程的路由，配置了如下URL模式：</p>
<ul>
    <li><code>process</code>：处理支付的视图</li>
    <li><code>done</code>：支付成功的视图</li>
    <li><code>canceled</code>：支付未成功的视图</li>
</ul>
<p>编辑<code>myshop</code>项目的根<code>urls.py</code>文件，为<code>payment</code>应用配置二级路由：</p>
<pre>
urlpatterns = [
    # ...
    <b>path('payment/', include('payment.urls', namespace='payment')),</b>
    path('', include('shop.urls', namespace='shop')),
]
</pre>
<p>依然要注意这一行要放到<code>shop.urls</code>上边，否则无法被解析到。</p>
<p>之后是建立视图，在payment目录下建立templates/payment/目录，并在其中建立 process.html， done.html，canceled.html三个模板。先来编写process.html：</p>
<p>在<code>payment</code>应用内建立下列目录和文件结构：</p>
<pre>
templates/
    payment/
        process.html
        done.html
        canceled.html
</pre>
<p>编辑<code>payment/process.html</code>，添加下列代码：</p>
<pre>
{% extends "shop/base.html" %}

{% block title %}Pay by credit card{% endblock %}

{% block content %}
  &lt;h1>Pay by credit card&lt;/h1>
  &lt;form action="." id="payment" method="post">

    &lt;label for="card-number">Card Number&lt;/label>
    &lt;div id="card-number" class="field">&lt;/div>

    &lt;label for="cvv">CVV&lt;/label>
    &lt;div id="cvv" class="field">&lt;/div>

    &lt;label for="expiration-date">Expiration Date&lt;/label>
    &lt;div id="expiration-date" class="field">&lt;/div>

    &lt;input type="hidden" id="nonce" name="payment_method_nonce" value="">
    {% csrf_token %}
    &lt;input type="submit" value="Pay">
  &lt;/form>
    &lt;!-- Load the required client component. -->
  &lt;script src="https://js.braintreegateway.com/web/3.29.0/js/client.min.js">&lt;/script>
    &lt;!-- Load Hosted Fields component. -->
  &lt;script src="https://js.braintreegateway.com/web/3.29.0/js/hosted-fields.min.js">&lt;/script>
  &lt;script>
    var form = document.querySelector('#payment');
    var submit = document.querySelector('input[type="submit"]');

    braintree.client.create({
        authorization: '{{ client_token }}'
    }, function (clientErr, clientInstance) {
        if (clientErr) {
            console.error(clientErr);
            return;
        }

        braintree.hostedFields.create({
            client: clientInstance,
            styles: {
                'input': {'font-size': '13px'},
                'input.invalid': {'color': 'red'},
                'input.valid': {'color': 'green'}
            },
            fields: {
                number: {selector: '#card-number'},
                cvv: {selector: '#cvv'},
                expirationDate: {selector: '#expiration-date'}
            }
        }, function (hostedFieldsErr, hostedFieldsInstance) {
            if (hostedFieldsErr) {
                console.error(hostedFieldsErr);
                return;
            }

            submit.removeAttribute('disabled');

            form.addEventListener('submit', function (event) {
                event.preventDefault();

                hostedFieldsInstance.tokenize(function (tokenizeErr, payload) {
                    if (tokenizeErr) {
                        console.error(tokenizeErr);
                        return;
                    }
                    // set nonce to send to the server
                    document.getElementById('nonce').value = payload.nonce;
                    // submit form
                    document.getElementById('payment').submit();
                });
            }, false);
        });
    });
  &lt;/script>
{% endblock %}
</pre>
<p>这是用户填写信用卡信息并且提交支付的模板，我们用<code>&lt;div&gt;</code>替代<code>&lt;input&gt;</code>使用在信用卡号，CVV码和过期日期字段上。这些字段就是Braintree JavaScript客户端渲染的iframe字段。还使用了一个名称为<code>payment_method_nonce</code>的<code>&lt;input&gt;</code>元素用于提交交易ID到后端。</p>
<p>在模板中还导入了Braintree JavaScript SDK的<code>client.min.js</code>和Hosted Fields组件<code>hosted-fields.min.js</code>，然后执行了下列JS代码：</p>
<ol>
    <li>使用<code>braintree.client.create()</code>方法，传入<code>client_token</code>即<code>payment_process</code>视图里生成的临时token，实例化Braintree JavaScript 客户端。</li>
    <li>使用<code>braintree.hostedFields.create()</code>实例化Hosted Field组件</li>
    <li>给<code>input</code>字段应用自定义样式</li>
    <li>给<code>cardnumber</code>，<code>cvv</code>, 和<code>expiration-date</code>字段设置<code>id</code>选择器</li>
    <li>给表单的<code>submit</code>行为绑定一个事件，当表单被点击提交时，Braintree SDK 使用表单中的信息，生成交易token放入<code>payment_method_nonce</code>字段中，然后提交表单。</li>
</ol>
<p>编辑<code>payment/done.html</code>文件，添加下列代码：</p>
<pre>
{% extends "shop/base.html" %}
{% block content %}
    &lt;h1>Your payment was successful&lt;/h1>
    &lt;p>Your payment has been processed successfully.&lt;/p>
{% endblock %}
</pre>
<p>这是订单成功支付时用户被重定向的页面。</p>
<p>编辑<code>canceled.html</code>，添加下列代码：</p>
<pre>
{% extends "shop/base.html" %}
{% block content %}
    &lt;h1>Your payment has not been processed&lt;/h1>
    &lt;p>There was a problem processing your payment.&lt;/p>
{% endblock %}
</pre>
<p>这是订单未支付成功时用户被重定向的页面。之后我们来试验一下付款。</p>

<h3 id="c8-1-4"><span class="title">1.4</span>测试支付</h3>
<p>打开系统命令行窗口然后运行RabbitMQ：</p>
<pre>rabbitmq-server</pre>
<p>再启动一个命令行窗口，启动Celery worker：</p>
<pre>celery -A myshop worker -l info</pre>
<p>再启动一个命令行窗口，启动站点：</p>
<pre>python manage.py runserver</pre>
<p>之后在浏览器中打开<a href="http://127.0.0.1:8000/" target="_blank">http://127.0.0.1:8000/</a>加入一些商品到购物车，提交订单，当按下PLACE ORDER按钮后，订单信息被保存进数据库，订单ID被附加到session上，然后进入支付页面。</p>
<p>支付页面从session中取得订单id然后在iframe中渲染Hosted Fields，像下图所示：</p>
<p><img src="http://img.conyli.cc/django2/C08-03.jpg" alt=""></p>
<p>可以看一下页面的HTML代码，从而理解什么是Hosted Fields。</p>
<p>针对沙盒测试环境，Braintree提供了一些测试用的信用卡资料，可以进行付款成功或失败的测试，可以在<a
        href="https://developers.braintreepayments.com/guides/credit-cards/testing-go-live/python" target="_blank">https://developers.braintreepayments.com/guides/credit-cards/testing-go-live/python</a>找到，我们来使用<code>4111 1111 1111 1111</code>这个信用卡号，在CVV码中填入<code>123</code>，到期日期填入未来的某一天比如<code>12/20</code>：</p>
<p><img src="http://img.conyli.cc/django2/C08-04.jpg" alt=""></p>
<p>之后点击Pay，应该可以看到成功页面：</p>
<p><img src="http://img.conyli.cc/django2/C08-05.jpg" alt=""></p>
<p>说明付款已经成功。可以在<a href="https://sandbox.braintreegateway.com/login" target="_blank">https://sandbox.braintreegateway.com/login</a>登录，然后在左侧菜单选Transaction里搜索最近的交易，可以看到如下信息：</p>
<p><img src="http://img.conyli.cc/django2/C08-i01.jpg" alt=""></p>
<p class="emp">译者注：Braintree网站在成书后有部分改版，读者看到的支付详情页面可能与上述图片有一些区别。</p>
<p>然后再查看管理站点<a href="http://127.0.0.1:8000/admin/orders/order/" target="_blank">http://127.0.0.1:8000/admin/orders/order/</a>中的对应记录，该订单应该已经被标记为已支付，而且记录了交易ID，如下图所示：</p>
<p><img src="http://img.conyli.cc/django2/C08-07.jpg" alt=""></p>
<p>我们现在就成功集成了支付功能。</p>

<h3 id="c8-1-5"><span class="title">1.5</span>正式上线</h3>
<p>在沙盒环境中测试通过之后，需要正式上线的话，需要到<a href="https://www.braintreepayments.com" target="_blank">https://www.braintreepayments.com</a>创建正式账户。</p>
<p>在部署到生产环境时，需要将<code>settings.py</code>中的商户ID和公钥私钥更新为正式账户的对应信息，然后将其中的<code>Environment.Sandbox</code>修改为<code>Environment.Production</code>。正式上线的具体步骤可以参考：<a href="https://developers.braintreepayments.com/start/go-live/python" target="_blank">https://developers.braintreepayments.com/start/go-live/python</a>。</p>

<h2 id="c8-2"><span class="title">2</span>导出订单为CSV文件</h2>
<p>很多情况下，我们的网站将数据库中的信息导出，可能为了和其他系统进行数据交换，或者给人阅读。常用的数据交换格式除了之前我们提到过的JSON，CSV（逗号分隔数据）文件也是一种得到广泛使用的数据格式。</p>
<p>CSV文件是一个纯文本文件，包含很多条记录。通常一行是一条记录，用逗号分隔其中的每个字段对应的值。由于导出网站数据库数据这种功能一般不会对普通用户开放，所以这里我们准备自定义管理后台，增加导出CSV文件的功能。</p>

<h3><b>给管理后台增加自定义功能（actions)</b></h3>
<p>这里的actions，是特指Django提供的下拉式功能菜单中的具体选项，如图所示，Django默认对于数据提供了删除的功能：</p>
<img src="http://img.conyli.cc/django2/C08-08.jpg" alt="">
<p>Django提供针对管理后台的很多设置。我们准备通过修改actions列表视图，来为管理后台增加自定义功能。</p>
<p>一个功能的工作流程是：一个用户先从列出的所有字段或者对象中选择要处理的内容，然后从功能菜单中选择要使用的功能，之后执行该功能。</p>
<p>可以通过写一个符合要求的自定义函数作为一项action，这个函数要接受如下参数：</p>
<ul>
    <li>当前的ModelAdmin类，也就是在操作哪个数据表</li>
    <li>当前的request对象</li>
    <li>用户选中的内容，也就是一个QuerySet</li>
</ul>
<p>在选中一个action选项然后点击旁边的Go按钮的时候，该函数就会被执行。</p>
<p>我们就准备在下拉action清单里增加一项导出CSV数据的功能，为此先来修改orders应用中的admin.py，将下列代码加在定义 OrderAdmin 类之前：</p>
<pre>
import csv
import datetime
from django.http import HttpResponse

def exprot_to_csv(modeladmin, request, queryset):
    opts = modeladmin.model._meta
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = 'attachment; filename={}.csv'.format(opts.verbose_name)
    writer = csv.writer(response)

    fields = [field for field in opts.get_fields() if not field.many_to_many and not field.one_to_many]
    writer.writerow(field.verbose_name for field in fields)

    for obj in queryset:
        data_row = []
        for field in fields:
            value = getattr(obj, field.name)
            if isinstance(value, datetime.datetime):
                value = value.strftime('%d/%m/%Y')
            data_row.append(value)
        writer.writerow(data_row)
    return response


exprot_to_csv.short_description = 'Export to CSV'
</pre>
<p>在这个函数里我们做了如下事情：</p>
<ol>
    <li>建立一个HttpResponse对象，类型是text/csv。</li>
    <li>还附加了一个Header信息，告诉这个请求带有一个附加文件。从当前的类，也就是modeladmin参数里，拿其元类，然后下边用到元类的verboser_属性的值用于生成文件名。</li>
    <li>以HttpResponse作为参数实例化一个writer对象，用于后边向HTTP请求里写数据。</li>
    <li>取当前类的所有不是外键的字段对象，放到列表中去。</li>
    <li>使用一个两层嵌套for循环，对于传入的QuerySet参数，对其中的每一个数据对象（一行数据），采用自省的方式，拿到该对象的所有字段名的值。然后挨个加入到一个临时列表中，之后将列表作为一行数据写入到HttpResponse中。</li>
    <li>最后返回HTTP响应</li>
    <li>最后设置了该函数对象的.short_description属性，该属性的值为在页面中显示出来的功能名称。</li>
</ol>
<p>之后在OrderAdmin类中增加一个新的actions属性，值是一个列表，放着对应的函数对象：</p>
<pre>
@admin.register(Order)
class OrderAdmin(admin.ModelAdmin):
    list_display = ['id', 'first_name', 'last_name', 'email', 'address', 'postal_code', 'city', 'paid', 'created',
                    'updated']
    list_filter = ['paid', 'created', 'updated']
    inlines = [OrderItemInline]
    <b>actions = [exprot_to_csv]</b>
</pre>
<p>然后到管理后台 http://127.0.0.1:8000/admin/orders/order/ 查看订单类，页面如下：</p>
<img src="http://img.conyli.cc/django2/C08-09.jpg" alt="">
<p>可以看到在actions里出现了一项新功能，就是导出到CSV，点击下载，就可以下载到一个文件。</p>
<p style="color: red">注意这里作者的源代码中并没有在orders应用的models.py中为Order类的 meta 类增加 verbose_name 属性，所以文件名是download。手工增加verboser_name的值为'order'，这样才能下载到和原书里写的名称一样的order.csv文件。</p>
<p>CSV文件可以用纯文本编辑器如Notepad++或者IDE打开，可以看到里边的内容类似：</p>
<pre>
ID,first name,last name,email,address,postal
code,city,created,updated,paid,braintree id
3,Antonio,Melé,antonio.mele@gmail.com,Bank Street,WS
J11,London,25/02/2018,25/02/2018,True,2bwkx5b6
</pre>
<p>这样就实现了导出数据为CSV文件的功能，Django中将数据输出为CSV的说明可以参考<a href="https://docs.djangoproject.com/en/2.0/howto/outputting-csv/" target="_blank">官方文档</a>。</p>

<h3><b>用自定义视图扩展管理后台的功能</b></h3>
<p>之前我们使用了增加action的方法给管理后台增加了导出CSV文件的功能。有时候，可能需要对管理后台进行更多的自定义。Django的管理后台并不特殊，也是一个应用，非常易于扩展，可以更改源代码，模板样式，增添功能，甚至可以完全重新编写管理后台本身（从settings.py中将<code>'django.contrib.admin'</code>更换为自行编写的应用并配置URL）。唯一的要求就是管理站点所有的功能应当只允许管理员身份的用户进行登录或者做一些设置（比如只允许从本地地址登录管理后台）。</p>
<p>我们这次来修改一下管理后台，增加一个自定义的功能用于显示一个订单的信息。修改orders应用中的views.py，增加如下内容：</p>
<pre>
from django.contrib.admin.views.decorators import staff_member_required
from django.shortcuts import get_object_or_404
from .models import Order

@staff_member_required
def admin_order_detail(request, order_id):
    order = get_object_or_404(Order, id=order_id)
    return render(request, 'admin/orders/order/detail.html', {'order': order})
</pre>
<p>@staff_member_required装饰器顾名思义，就是只有User表里is_staff和is_active字段同时为True才能使用被装饰的视图。</p>
<p>然后配置orders应用的urls.py，增加一条路由：</p>
<pre>
path('admin/order/&lt;int:order_id>/', views.admin_order_detail, name='admin_order_detail')
</pre>
<p>然后建立上边视图所需的模板，新建 orders/templates/admin/orders/order/detail.html并且编辑：</p>
<pre>
{% extends "admin/base_site.html" %}
{% load static %}
{% block extrastyle %}
    &lt;link rel="stylesheet" type="text/css" href="{% static "css/admin.css" %}"/>
{% endblock %}
{% block title %}
    Order {{ order.id }} {{ block.super }}
{% endblock %}
{% block breadcrumbs %}
    &lt;div class="breadcrumbs">
        &lt;a href="{% url "admin:index" %}">Home&lt;/a> &rsaquo;
        &lt;a href="{% url "admin:orders_order_changelist" %}">Orders&lt;/a>
        &rsaquo;
        &lt;a href="{% url "admin:orders_order_change" order.id %}">Order {{ order.id }}&lt;/a>
        &rsaquo; Detail
    &lt;/div>
{% endblock %}
{% block content %}
    &lt;h1>Order {{ order.id }}&lt;/h1>
    &lt;ul class="object-tools">
        &lt;li>
            &lt;a href="#" onclick="window.print();">Print order&lt;/a>
        &lt;/li>
    &lt;/ul>
    &lt;table>
        &lt;tr>
            &lt;th>Created&lt;/th>
            &lt;td>{{ order.created }}&lt;/td>
        &lt;/tr>
        &lt;tr>
            &lt;th>Customer&lt;/th>
            &lt;td>{{ order.first_name }} {{ order.last_name }}&lt;/td>
        &lt;/tr>
        &lt;tr>
            &lt;th>E-mail&lt;/th>
            &lt;td>&lt;a href="mailto:{{ order.email }}">{{ order.email }}&lt;/a>&lt;/td>
        &lt;/tr>
        &lt;tr>
            &lt;th>Address&lt;/th>
            &lt;td>{{ order.address }}, {{ order.postal_code }} {{ order.city }}&lt;/td>
        &lt;/tr>
        &lt;tr>
            &lt;th>Total amount&lt;/th>
            &lt;td>${{ order.get_total_cost }}&lt;/td>
        &lt;/tr>
        &lt;tr>
            &lt;th>Status&lt;/th>
            &lt;td>{% if order.paid %}Paid{% else %}Pending payment{% endif %}&lt;/td>
        &lt;/tr>
    &lt;/table>
    &lt;div class="module">
        &lt;div class="tabular inline-related last-related">
            &lt;table>
                &lt;caption>Items bought&lt;/caption>
                &lt;thead>
                &lt;tr>
                    &lt;th>Product&lt;/th>
                    &lt;th>Price&lt;/th>
                    &lt;th>Quantity&lt;/th>
                    &lt;th>Total&lt;/th>
                &lt;/tr>
                &lt;/thead>
                &lt;tbody>
                {% for item in order.items.all %}
                    &lt;tr class="row{% cycle "1" "2" %}">
                        &lt;td>{{ item.product.name }}&lt;/td>
                        &lt;td class="num">${{ item.price }}&lt;/td>
                        &lt;td class="num">{{ item.quantity }}&lt;/td>
                        &lt;td class="num">${{ item.get_cost }}&lt;/td>
                &lt;/tr>
                {% endfor %}
                &lt;tr class="total">
                    &lt;td colspan="3">Total&lt;/td>
                    &lt;td class="num">${{ order.get_total_cost }}&lt;/td>
                &lt;/tr>
                &lt;/tbody>
            &lt;/table>
        &lt;/div>
    &lt;/div>
{% endblock %}
</pre>
<p>首先我们继承django 管理后台的模板，CSS文件也采用django后台的样式表。然后根据母版里的block的名称分别来编写内容，有增加链接和用表格展示内容等。这里很多内容不一一解释，都是按照继承母版的要求以及django admin内部结构和urls来写的，具体可以参考<a
        href="https://github.com/django/django/tree/2.1/django/contrib/admin/templates/admin" target="_blank">django 2.1 中所有的内置模板</a>。</p>
<p>模板也可以不继承Django 的内置模板，完全重写。需要将自己编写的模板命名为与原来模板相同，然后替换原来的模板文件。当然，如果不想使用内置的admin模块，完全自行编写，就没有这个限制了。</p>
<p>最后，还需要将每个Object的链接都链到我们自己的视图函数上，编辑orders应用的admin.py，在OrderAdmin类之前增加如下代码：</p>
<pre>
from django.urls import reverse
from django.utils.safestring import mark_safe


def order_detail(obj):
    return mark_safe('&lt;a href="{}">View&lt;/a>'.format(reverse('orders:admin_order_detail', args=[obj.id])))
</pre>
<p>由于我们要渲染一段字符串当做HTML元素解析，所以必须使用mark_safe。这个函数的意思就是取得一个具体的Order对象然后生成一个链接到刚才编写的自定义视图函数，进入自定义模板。这个函数的名称就像一个字段名一样可以增加在页面显示中。需要在OrderAdmin中配置一下，修改OrderAdmin类：</p>
<pre>
@admin.register(Order)
class OrderAdmin(admin.ModelAdmin):
    list_display = ['id', 'first_name', 'last_name', 'email', 'address', 'postal_code', 'city', 'paid', 'created',
                    'updated', <b>order_detail</b>]
    list_filter = ['paid', 'created', 'updated']
    inlines = [OrderItemInline]
    actions = [exprot_to_csv]
</pre>
<p>然后启动站点，到 http://127.0.0.1:8000/admin/orders/order/ 查看，可以看到新增了一列：</p>
<img src="http://img.conyli.cc/django2/C08-10.jpg" alt="">
<p>点击View查看详情，会进入Django 管理后台风格的订单详情页：</p>
<img src="http://img.conyli.cc/django2/C08-11.jpg" alt="">

<h2><b>动态生成PDF</b></h2>
<p>本章的最后一个任务是实现通过订单动态的生成PDF发票信息。有很多Python库都可以用来生成PDF，常用的是Reportlab库，该库也是django 2.1 <a href="https://docs.djangoproject.com/en/2.1/howto/outputting-pdf/" target="_blank">官方文档</a>推荐使用的库。</p>
<p>Reportlab生成的PDF是黑白的，而且是直接从文本生成，无法带有样式。更好的做法是建立一个模板，然后将其转换成PDF，这样转换出来的PDF具有一定的格式，方便给用户观看。这里我们使用WeasyPrint库，这个库用来从HTML文件生成PDF文件。</p>

<h3><b>安装WeasyPrint</b></h3>
<p>Reportlab的安装不再赘述。WeasyPrint针对不同的系统需要一些依赖库，到其<a href="https://weasyprint.readthedocs.io/en/latest/" target="_blank">官方文档</a>查看，例如在Windows上使用64位的Python，就需要安装<a
        href="https://github.com/tschoonj/GTK-for-Windows-Runtime-Environment-Installer" target="_blank">GTK3-runtime64位版本</a>，将GTK3的路径加入环境变量。</p>
<p>然后安装WeasyPrint：</p>
<pre>
pip install WeasyPrint==0.42.3
</pre>
<p>这是第三个到翻译为止还没有更新过的库。</p>

<h3><b>建立PDF模板</b></h3>
<p>这个PDF模板也就是我们打算转换成PDF的HTML文件。我们需要建立一个带有订单内容和CSS样式的模板，每次将最终生成的页面传给WeasyPrint生成PDF文件。</p>
<p>在orders应用的templates/orders/order/目录下建立pdf.html：</p>
<pre>
&lt;html>
&lt;body>
&lt;h1>My Shop&lt;/h1>
&lt;p>
    Invoice no. {{ order.id }}<span style="color:red">&lt;br></span>
    &lt;span class="secondary">
{{ order.created|date:"M d, Y" }}
&lt;/span>
&lt;/p>
&lt;h3>Bill to&lt;/h3>
&lt;p>
    {{ order.first_name }} {{ order.last_name }}&lt;br>
    {{ order.email }}&lt;br>
    {{ order.address }}&lt;br>
    {{ order.postal_code }}, {{ order.city }}
&lt;/p>
&lt;h3>Items bought&lt;/h3>
&lt;table>
    &lt;thead>
    &lt;tr>
        &lt;th>Product&lt;/th>
        &lt;th>Price&lt;/th>
        &lt;th>Quantity&lt;/th>
        &lt;th>Cost&lt;/th>
    &lt;/tr>
    &lt;/thead>
    &lt;tbody>
    {% for item in order.items.all %}
        &lt;tr class="row{% cycle "1" "2" %}">
            &lt;td>{{ item.product.name }}&lt;/td>
            &lt;td class="num">${{ item.price }}&lt;/td>
            &lt;td class="num">{{ item.quantity }}&lt;/td>
            &lt;td class="num">${{ item.get_cost }}&lt;/td>
    &lt;/tr>
    {% endfor %}
    &lt;tr class="total">
        &lt;td colspan="3">Total&lt;/td>
        &lt;td class="num">${{ order.get_total_cost }}&lt;/td>
    &lt;/tr>
    &lt;/tbody>
&lt;/table>
&lt;span class="{% if order.paid %}paid{% else %}pending{% endif %}">
{% if order.paid %}Paid{% else %}Pending payment{% endif %}
&lt;/span>
&lt;/body>
&lt;/html>
</pre>
<p>注意第五行标红的部分，原书错误的写成了<code>&lt;/br&gt;</code>。这个模板的内容很简单，就是将订单的用户信息和商品信息全部展示出来。之后我们要建立一个视图函数来渲染这个HTML文件。</p>

<h3><b>建立视图渲染PDF文件</b></h3>
<p>在orders应用的views.py中增加下列代码：</p>
<pre>
@staff_member_required
def admin_order_pdf(request, order_id):
    order = get_object_or_404(Order, id=order_id)
    html = render_to_string('orders/order/pdf.html', {'order': order})
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = 'filename="order_{}"'.format(order.id)
    weasyprint.HTML(string=html).write_pdf(response, stylesheets=[weasyprint.CSS(settings.STATIC_ROOT + 'css/pdf.css')])
    return response
</pre>
<p>这个视图从一个订单中生成一个PDF文件，按照如下的顺序：</p>
<ul>
    <li>使用了@staff_member_required装饰器让这个功能只有超级用户可以使用</li>
    <li>通过order_id拿到订单对象，然后使用render_to_string方法将pdf.html加上订单信息渲染成字符串。</li>
    <li>设置HTTP请求头以便一会浏览器可以下载对应的pdf文件</li>
    <li>调用WeasyPrint，将渲染后的页面配上css文件，生成最终的PDF，写到HttpResponse里</li>
    <li>视图返回设置了附加PDF文件和文件名响应的请求给浏览器</li>
</ul>
<p>细心的读者会发现settings.py中此时还没有STATIC_ROOT变量，这个变量是表示整个项目的静态文件的基础路径。而之前在模板里使用 load static标签，是指的应用目录下的static目录。在settings.py里设置该参数：</p>
<pre>
STATIC_ROOT = os.path.join(BASE_DIR, 'static/')
</pre>
<p>将其设置在项目根目录的static目录内。下一步比较有趣，打开终端或者Pycharm的执行manage.py命令：</p>
<pre>
python manage.py collectstatic
</pre>
<p>之后会看到：</p>
<pre>
122 static files copied to 'D:\Coding\sites\myshop\static'.
</pre>
<p>这个命令就是如果设置了STATIC_ROOT变量后，会把所有已经注册的应用里的static目录里的内容复制到项目根目录/static/文件下边来。还可以在settings.py里设置STATICFILES_DIRS，在执行该命令时就会连STATICFILES_DIRS内的目录中的文件一并复制过来。如果再次执行该命令，会提示是否覆盖原来的相同文件。</p>
<p>视图写好了，在orders应用的urls.py增加一条：</p>
<pre>
path('admin/order/&lt;int:order_id>/pdf/', views.admin_order_pdf, name='admin_order_pdf'),
</pre>
<p>从一开始使用@staff_member_required大家可能就看出来了，像导出CSV一样，我们要再增加一个字段放生成PDF的链接。打开orders应用的admin.py，在OrderAdmin类之前增加：</p>
<pre>
def order_pdf(obj):
    return mark_safe('&lt;a href="{}">View&lt;/a>'.format(reverse('orders:admin_order_pdf', args=[obj.id])))

order_pdf.short_description = 'Invoice'
</pre>
<p>还需给OrderAdmin的list_display增加这个新的字段：</p>
<pre>
@admin.register(Order)
class OrderAdmin(admin.ModelAdmin):
    list_display = ['id', 'first_name', 'last_name', 'email', 'address', 'postal_code', 'city', 'paid', 'created',
                    'updated', order_detail, <b>order_pdf</b>]
</pre>
<p>之后启动站点，到http://127.0.0.1:8000/admin/orders/order/可以看到新增了一列字段用于转换PDF：</p>
<img src="http://img.conyli.cc/django2/C08-12.jpg" alt="">
<p>点击PDF链接，浏览器应该会下载一个名为order_xx.pdf的文件，如果是尚未支付的订单，样式如下：</p>
<img src="http://img.conyli.cc/django2/C08-13.jpg" alt="">
<p>已经支付的订单，则类似这样：</p>
<img src="http://img.conyli.cc/django2/C08-14.jpg" alt="">
<p style="color:red">WeasyPrint的安装依赖比较多，原书里对这一块没有详细讲解，交给用户自己去进行。结果译者在windows环境折腾了好久，运行的时候依然找不到cairo库，后来在linux安装了N多依赖后终于运行成功。</p>


<h3><b>使用电子邮件发送PDF文件</b></h3>
<p>在之前我们使用Celery异步任务，在用户提交一个订单的时候异步发送邮件给用户。现在在支付成功的时候，我们发送带有这个PDF文件的邮件给用户。编辑payment应用中的views.py视图，导入一些新功能后编辑payment_process视图：</p>
<pre>
from django.template.loader import render_to_string
from django.core.mail import EmailMessage
from django.conf import settings
import weasyprint
from io import BytesIO

def payment_process(request):
    # ......
    if request.method == "POST":
        # ......
        # 如果提交交易信息成功,将已支付和交易id记录到Order表中
        if result.is_success:
            # ......
            order.save()

            # 建立邮件
            subject = 'My Shop - Invoice no. {}'.format(order.id)
            message = 'Please, find attached the invoice for your recent purchase.'
            email = EmailMessage(subject, message, 'admin@myshop.com', [order.email])

            # 生成PDF文件
            html = render_to_string('orders/order/pdf.html', {'order': order})
            out = BytesIO()
            stylesheets = [weasyprint.CSS(settings.STATIC_ROOT + 'css/pdf.css')]
            weasyprint.HTML(string=html).write_pdf(out, stylesheets=stylesheets)

            # 给邮件附加PDF文件
            email.attach('order_{}.pdf'.format(order.id), out.getvalue(), 'application/pdf')

            # 发送邮件
            email.send()
            return redirect('payment:done')
            # ......
</pre>
<p>这里使用WeasyPrint的方式和生成PDF文件的基本类似，唯一不同的就是没有向HttpResponse中写数据，而是向一个空的字节对象中写数据。由于PDF是一个二进制文件，所以就采用了这个方法。邮件我们使用了Django 的EmailMessage模块来实例化一个邮件对象，在有了二进制文件对象之后，调用email.attach方法，设置邮件附件中的文件名，内容和类型。</p>
<p>这就完成了发送邮件的工作。值得注意的是这里发送邮件是同步的，如果读者愿意，可以将发送邮件的代码分离，配置为使用Celery异步发送。</p>

<h1><b>总结</b></h1>
<p>这一章的实战性质越来越强，真正的集成了可以用的支付网关，以及让我们的网站对外提供信息的方式，除了展示页面之外，又多了生成CSV文件和PDF文件的方式。</p>
<p>本章的主要内容有：</p>
<ul>
    <li>Braintree支付网关沙盒测试的注册和使用</li>
    <li>braintree模块的使用，使用braintree的JS代码生成前端页面</li>
    <li>给管理后台增加action的方法，通过管理类中增加actions属性，指定为按照规定自行编写的函数</li>
    <li>为管理后台中的模型增加自定义的功能字段</li>
    <li>WeasyPrint的安装和使用</li>
    <li>STATIC_ROOT变量的设置和collectstatic命令</li>
    <li>django 发送邮件附加附件的方法</li>
</ul>


</body>
</html>