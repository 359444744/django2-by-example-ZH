<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="css/normalize.min.css">
    <link rel="stylesheet" href="css/base.css">
    <title>第七章 创建电商网站</title>

</head>
<body>
<h1 id="top"><b>创建电商网站</b></h1>
<p>在上一章里，创建了用户关注系统和行为流应用，还学习了使用Django的信号功能与使用Redis数据库存储图片浏览次数和排名。这一章将学习如何创建一个基础的电商网站。本章将学习创建商品品类目录，通过session实现购物车功能。还将学习创建自定义上下文管理器和使用Celery执行异步任务。</p>
<p>本章的要点有：</p>
<ul>
    <li>创建商品品类目录</li>
    <li>使用session创建购物车</li>
    <li>管理客户订单</li>
    <li>使用Celery异步向用户发送邮件通知</li>
</ul>

<h2 id="c7-1"><span class="title">1</span>创建电商网站项目</h2>
<p>我们要创建一个电商网站项目。用户能够浏览商品品类目录，然后将具体商品加入购物车，最后还可以通过购物车生成订单。本章电商网站的如下功能：</p>
<ul>
    <li>创建商品品类模型并加入管理后台，创建视图展示商品品类</li>
    <li>创建购物车系统，用户浏览网站的时购物车中一直保存着用户的商品</li>
    <li>创建提交订单的页面</li>
    <li>订单提交成功后异步发送邮件给用户</li>
</ul>
<p>打开系统命令行窗口，为新项目配置一个新的虚拟环境并激活：</p>
<pre>
mkdir env
virtualenv env/myshop
source env/myshop/bin/activate
</pre>
<p>然后在虚拟环境中安装Django：</p>
<pre>pip install Django==2.0.5</pre>
<p>新创建一个项目叫做<code>myshop</code>，之后创建新应用叫<code>shop</code>：</p>
<pre>
django-admin startproject myshop
cd myshop/
django-admin startapp shop
</pre>
<p>编辑<code>settings.py</code>文件，激活<code>shop</code>应用：</p>
<pre>
INSTALLED_APPS = [
    # ...
    <b>'shop.apps.ShopConfig',</b>
]
</pre>
<p>现在应用已经激活，下一步是设计数据模型。</p>

<h3 id="c7-1-1"><span class="title">1.1</span>创建商品品类模型</h3>
<p>我们的商品品类模型包含一系列商品大类，每个商品大类中包含一系列商品。每一个商品都有一个名称，可选的描述，可选的图片，价格和是否可用属性。编辑<code>shop</code>应用的<code>models.py</code>文件：</p>
<pre>
from django.db import models


class Category(models.Model):
    name = models.CharField(max_length=200, db_index=True)
    slug = models.SlugField(max_length=200, db_index=True, unique=True)

    class Meta:
        ordering = ('name',)
        verbose_name = 'category'
        verbose_name_plural = 'categories'

    def __str__(self):
        return self.name


class Product(models.Model):
    category = models.ForeignKey(Category, related_name='category', on_delete=models.CASCADE)
    name = models.CharField(max_length=200, db_index=True)
    slug = models.SlugField(max_length=200, db_index=True)
    image = models.ImageField(upload_to='products/%Y/%m/%d', blank=True)
    description = models.TextField(blank=True)
    price = models.DecimalField(max_digits=10, decimal_places=2)
    available = models.BooleanField(default=True)
    created = models.DateTimeField(auto_now_add=True)
    updated = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ('name',)
        index_together = (('id', 'slug'),)

    def __str__(self):
        return self.name
</pre>
<p>这是我们的<code>Category</code>和<code>Product</code>模型。<code>Category</code>包含<code>name</code>字段和设置为不可重复的<code>slug</code>字段（<code>unique</code>同时也意味着创建索引）。<code>Product</code>模型的字段如下：</p>
<ul>
    <li><code>category</code>：关联到<code>Category</code>模型的外键。这是一个多对一关系，一个商品必定属于一个品类，一个品类包含多个商品。</li>
    <li><code>name</code>：商品名称。</li>
    <li><code>slug</code>：商品简称，用于创建规范化URL。</li>
    <li><code>image</code>：可选的商品图片。</li>
    <li><code>description</code>：可选的商品图片。</li>
    <li><code>price</code>：该字段使用了Python的<code>decimal.Decimal</code>类，用于存储商品的金额，通过<code>max_digits</code>设置总位数，<code>decimal_places=2</code>设置小数位数。</li>
    <li><code>availble</code>：布尔值，表示商品是否可用，可以用于切换该商品是否可以购买。</li>
    <li><code>created</code>：记录商品对象创建的时间。</li>
    <li><code>updated</code>：记录商品对象最后更新的时间。</li>
</ul>
<p>这里需要特别说明的是<code>price</code>字段，使用<code>DecimalField</code>，而不是<code>FloatField</code>，以避免小数尾差。</p>
<p class="hint">凡是涉及到金额相关的数值，使用<code>DecimalField</code>字段。<code>FloatField</code>的后台使用Python的<code>float</code>类型，而<code>DecimalField</code>字段后台使用Python的<code>Decimal</code>类，可以避免出现浮点数的尾差。</p>
<p>在<code>Product</code>模型的<code>Meta</code>类中，使用<code>index_together</code>设置<code>id</code>和<code>slug</code>字段建立联合索引，这样在同时使用两个字段的索引时会提高效率。</p>
<p>由于使用了<code>ImageField</code>，还需要安装<code>Pillow</code>库：</p>
<pre>pip install Pillow==5.1.0</pre>
<p>之后执行数据迁移程序，创建数据表。</p>



<h3 id="c7-1-2"><span class="title">1.2</span>将模型注册到管理后台</h3>
<p>将我们的模型都添加到管理后台中，编辑<code>shop</code>应用的<code>admin.py</code>文件：</p>
<pre>
from django.contrib import admin
from .models import Category, Product

@admin.register(Category)
class CategoryAdmin(admin.ModelAdmin):
    list_display = ['name', 'slug']
    prepopulated_fields = {'slug': ('name',)}

@admin.register(Product)
class ProductAdmin(admin.ModelAdmin):
    list_display = ['name', 'slug', 'price', 'available', 'created', 'updated']
    list_filter = ['available', 'created', 'updated']
    list_editable = ['price', 'available']
    prepopulated_fields = {'slug': ('name',)}
</pre>
<p>我们使用了<code>prepopulated_fields</code>用于让<code>slug</code>字段通过<code>name</code>字段自动生成，在之前的项目中可以看到这么做很简便。在<code>ProductAdmin</code>中使用<code>list_editable</code>设置了可以编辑的字段，这样可以一次性编辑多行而不用点开每一个对象。注意所有在<code>list_editable</code>中的字段必须出现在<code>list_display</code>中。</p>
<p>之后创建超级用户。打开<a href="http://127.0.0.1:8000/admin/shop/product/add/" target="_blank">http://127.0.0.1:8000/admin/shop/product/add/</a>，使用管理后台添加一个新的商品品类和该品类中的一些商品，页面如下：</p>
<p><img src="http://img.conyli.cc/django2/C07-01.jpg" alt=""></p>
<p class="emp">译者注：这里图片上有一个<code>stock</code>字段，这是上一版的程序使用的字段。在本书内程序已经修改，但图片依然使用了上一版的图片。本项目中后续并没有使用<code>stock</code>字段。</p>

<h3 id="c7-1-3"><span class="title">1.3</span>创建商品品类视图</h3>
<p>为了展示商品，我们创建一个视图，用于列出所有商品，或者根据品类显示某一品类商品，编辑<code>shop</code>应用的<code>views.py</code>文件：</p>
<pre>
from django.shortcuts import render, get_object_or_404
from .models import Category, Product

def product_list(request, category_slug=None):
    category = None
    categories = Category.objects.all()
    products = Product.objects.filter(available=True)
    if category_slug:
        category = get_object_or_404(categories, slug=category_slug)
        products = products.filter(category=category)
    return render(request, 'shop/product/list.html',
                  {'category': category, 'categories': categories, 'products': products})
</pre>
<p>这个视图逻辑较简单，使用了<code>available=True</code>筛选所有可用的商品。设置了一个可选的<code>category_slug</code>参数用于选出特定的品类。</p>
<p>还需要一个展示单个商品详情的视图，继续编辑<code>views.py</code>文件：</p>
<pre>
def product_detail(request, id, slug):
    product = get_object_or_404(Product, id=id, slug=slug, availbable=True)
    return render(request, 'shop/product/detail.html', {'product': product})
</pre>
<p><code>product_detail</code>视图需要<code>id</code>和<code>slug</code>两个参数来获取商品对象。只通过ID可以获得商品对象，因为ID是唯一的，这里增加了<code>slug</code>字段是为了对搜索引擎优化。</p>
<p>在创建了上述视图之后，需要为其配置URL，在<code>shop</code>应用内创建<code>urls.py</code>文件并添加如下内容：</p>
<pre>
from django.urls import path
from . import views

app_name = 'shop'

urlpatterns = [
    path('', views.product_list, name='product_list'),
    path('&lt;slug:category_slug>/', views.product_list, name='product_list_by_category'),
    path('&lt;int:id>/&lt;slug:slug>/', views.product_detail, name='product_detail'),
]
</pre>
<p>我们为<code>product_list</code>视图定义了两个不同的URL，一个名称是<code>product_list</code>，不带任何参数，表示展示全部品类的全部商品；一个名称是<code>product_list_by_category</code>，带参数，用于显示指定品类的商品。还为<code>product_detail</code>视图配置了传入<code>id</code>和<code>slug</code>参数的URL。</p>
<p>这里要解释的就是product_list视图带一个默认值参数，所以默认路径进来后就是展示全部品类的页面。加上了具体某个品类，就展示那个品类的商品。详情页的URL使用id和slug来进行参数传递。</p>
<p>还需要编写项目的一级路由，编辑<code>myshop</code>项目的根<code>urls.py</code>文件：</p>
<pre>
from django.contrib import admin
from django.urls import path, <b>include</b>

urlpatterns = [
    path('admin/', admin.site.urls),
    <b>path('', include('shop.urls', namespace='shop')),</b>
]
</pre>
<p>我们为<code>shop</code>应用配置了名为<code>shop</code>的二级路由。</p>
<p>由于URL中有参数，就需要配置URL反向解析，编辑<code>shop</code>应用的<code>models.py</code>文件，导入<code>reverse()</code>函数，然后为<code>Category</code>和<code>Product</code>模型编写<code>get_absolute_url()</code>方法：</p>
<pre>
<b>from django.urls import reverse</b>

class Category(models.Model):
    # ......
    <b>def get_absolute_url(self):</b>
        <b>return reverse('shop:product_list_by_category',args=[self.slug])</b>

class Product(models.Model):
    # ......
    <b>def get_absolute_url(self):</b>
        <b>return reverse('shop:product_detail',args=[self.id,self.slug])</b>
</pre>
<p>这样就为模型的对象配置好了用于反向解析URL的方法，我们已经知道，<code>get_absolute_url()</code>是很好的获取具体对象规范化URL的方法。</p>

<h3 id="c7-1-4"><span class="title">1.4</span>创建商品品类模板</h3>
<p>现在需要创建模板，在<code>shop</code>应用下建立如下目录和文件结构：</p>
<pre>
templates/
    shop/
    base.html
    product/
        list.html
        detail.html
</pre>
<p>像以前的项目一样，<code>base.html</code>是母版，让其他的模板继承母版。编辑<code>base.html</code>：</p>
<pre>
{% load static %}
&lt;!DOCTYPE html>
&lt;html>
&lt;head>
    &lt;meta charset="utf-8"/>
    &lt;title>{% block title %}My shop{% endblock %}&lt;/title>
    &lt;link href="{% static "css/base.css" %}" rel="stylesheet">
&lt;/head>
&lt;body>
    &lt;div id="header">
        &lt;a href="/" class="logo">My shop&lt;/a>
    &lt;/div>
    &lt;div id="subheader">
        &lt;div class="cart">Your cart is empty.&lt;/div>
    &lt;/div>
    &lt;div id="content">
        {% block content %}
        {% endblock %}
    &lt;/div>
&lt;/body>
&lt;/html>
</pre>
<p>这是这个项目的母版。其中使用的CSS文件可以从随书源代码中复制到<code>shop</code>应用的<code>static/</code>目录下。</p>
<p>然后编辑<code>shop/product/list.html</code>：</p>
<pre>
{% extends "shop/base.html" %}
{% load static %}
{% block title %}
    {% if category %}{{ category.name }}{% else %}Products{% endif %}
{% endblock %}
{% block content %}
    &lt;div id="sidebar">
        &lt;h3>Categories&lt;/h3>
        &lt;ul>
            &lt;li {% if not category %}class="selected"{% endif %}>
                &lt;a href="{% url "shop:product_list" %}">All&lt;/a>
            &lt;/li>
            {% for c in categories %}
                &lt;li {% if category.slug == c.slug %}class="selected"
                    {% endif %}>
                    &lt;a href="{{ c.get_absolute_url }}">{{ c.name }}&lt;/a>
                &lt;/li>
            {% endfor %}
        &lt;/ul>
    &lt;/div>
    &lt;div id="main" class="product-list">
        &lt;h1>{% if category %}{{ category.name }}{% else %}Products
        {% endif %}&lt;/h1>
        {% for product in products %}
            &lt;div class="item">
                &lt;a href="{{ product.get_absolute_url }}">
                    &lt;img src="
                            {% if product.image %}{{ product.image.url }}{% else %}{% static "img/no_image.png" %}{% endif %}">
                &lt;/a>
                &lt;a href="{{ product.get_absolute_url }}">{{ product.name }}&lt;/a>
                &lt;br>
                ${{ product.price }}
            &lt;/div>
        {% endfor %}
    &lt;/div>
{% endblock %}
</pre>
<p>这是展示商品列表的模板，继承了<code>base.html</code>，使用<code>categories</code>变量在侧边栏显示品类的列表，在页面主体部分通过<code>products</code>变量展示商品清单。展示所有商品和具体某一类商品都采用这个模板。如果<code>Product</code>对象的<code>image</code>字段为空，我们显示一张默认的图片，可以在随书源码中找到<code>img/no_image.png</code>，将其拷贝到对应的目录。</p>
<p>由于使用了Imagefield，还需要对媒体文件进行一些设置，编辑settings.py文件加入下列内容：</p>
<pre>
MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media/')
</pre>
<p><code>MEDIA_URL</code>是保存用户上传的媒体文件的目录，<code>MEDIA_ROOT</code>是存放媒体文件的目录，通过<code>BASE_DIR</code>变量动态建立该目录。</p>
<p>为了让Django提供静态文件服务，还必须修改<code>shop</code>应用的<code>urls.py</code>文件：</p>
<pre>
<b>from django.conf import settings</b>
<b>from django.conf.urls.static import static</b>
urlpatterns = [
    # ...
]
<b>if settings.DEBUG:</b>
    <b>urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)</b>
</pre>
<p>注意仅在开发阶段才能如此设置。在生产环境中不能使用Django提供静态文件。使用管理后台增加一些商品，然后打开<a href="http://127.0.0.1:8000/" target="_blank">http://127.0.0.1:8000/</a>，可以看到如下页面：</p>
<p><img src="http://img.conyli.cc/django2/C07-02.jpg" alt=""></p>
<p>如果没有给商品上传图片，则会显示<code>no_image.png</code>，如下图：</p>
<p><img src="http://img.conyli.cc/django2/C07-03.jpg" alt=""></p>
<p>然后编写商品详情页<code>shop/product/detail.html</code>：</p>
<pre>
{% extends "shop/base.html" %}
{% load static %}
{% block title %}
    {{ product.name }}
{% endblock %}
{% block content %}
    &lt;div class="product-detail">
        &lt;img src="{% if product.image %}{{ product.image.url }}{% else %}
        {% static "img/no_image.png" %}{% endif %}">
        &lt;h1>{{ product.name }}&lt;/h1>
        &lt;h2>&lt;a href="{{ product.category.get_absolute_url }}">{{ product.category }}&lt;/a>&lt;/h2>
        &lt;p class="price">${{ product.price }}&lt;/p>
        {{ product.description|linebreaks }}
    &lt;/div>
{% endblock %}
</pre>
<p>在模板中调用<code>get_absolute_url()</code>方法用于展示对应类的商品，打开<a href="http://127.0.0.1:8000/" target="_blank">http://127.0.0.1:8000/</a>，然后点击任意一个商品，详情页如下：</p>
<p><img src="http://img.conyli.cc/django2/C07-04.jpg" alt=""></p>
<p>现在已经将商品品类和展示功能创建完毕。</p>

<h2 id="c7-2"><span class="title">2</span>创建购物车功能</h2>
<p>在开始做之前依然要思考一下，常见网站的购物车，在浏览整个网站，离开又返回的时候，购物车中的内容都可以保持原来的状态，那么其中的数据一定也是保存在某处。</p>
<p>购物车还一个突出的特点就是，如果将购物车中的商品下了订单，该商品就会从购物车中消失。</p>
<p>将购物车抽象成一个对象的话，这个对象很像一个数据库，挑选商品的时候往其中加入商品以及数量，下订单的时候减少商品和对应的数量。那么这个数据库应该保存在哪里呢？</p>
<p>答案就是session里，session很适合用来存储当前用户的一些小数据。</p>

<h3 id="c7-2-1"><span class="title">2.1</span>Django的session模块</h3>
<p>Django 的session模块在默认建立一个应用的时候，已经包含在settings.py里启用的中间件<code>'django.contrib.sessions.middleware.SessionMiddleware'</code>中。这个中间件会让所有的request都具有session属性。</p>
<p>request.session可以把它想象成是一个Python字典，可以存储任何Python的数据并且序列化我Json格式。简单的操作如下：</p>
<pre>
# 向session里存数据
request.session['foo'] = 'bar'

# 从session里取数据
request.session.get('foo')

# 删除session中的键值对
del request.session['foo']
</pre>
<p>session的详细介绍和命令可以参考本站的<a href="http://www.conyli.cc/archives/1283" target="_blank">django 中使用session</a>，该文章对应的版本是django 1.11.14，但与2.1没有区别。</p>
<p>这里需要注意一点的是，当用户先浏览站点再登录的时候，原来作为匿名用户的session会被一个新的认证用户的session所替代。很多电商网站有这样的功能：在未登录的情况下将商品加入购物车，在购买的时候进行登录，则购物车中的内容还在。这是因为后端在登录的时候，将匿名用户的session里的购物车数据复制到了登录用户的session中。</p>

<h3 id="c7-2-2"><span class="title">2.2</span>session设置</h3>
<p>django中可以配置session模块的一些参数，其中最重要的是 <code>SESSION_ENGINE</code>设置，设置session具体存储在何处。默认情况下，django.contrib.session模块将session数据保存在默认生成的django_session表中。</p>
<p>Django提供了如下几种类型的session可供选择：</p>
<ul>
<li>存放于数据库中的session：默认设置，即将session数据存放到settings.py中的DATABASES设置中的数据库内。</li>
<li>基于文件的session：保存在一个具体的文件中</li>
<li>缓存的session：存储在django 的缓存系统中，可以通过CACHES设置缓存。这种情况下速度最快。（怀念Redis了吗？）</li>
<li>缓存与数据库结合的方式：先存到缓存再持久化到数据库中。取数据时如果缓存内无数据，就从数据库中取。</li>
<li>Cookie方式：session存放在cookie中。</li>
</ul>


<h3 id="c7-2-3"><span class="title">2.3</span>session过期</h3>


<p>所有session相关的设置需要写在settings.py中，主要的设置有：</p>
<ul>
<li>SESSION_COOKIE_AGE 为秒数，默认为1209600（两个星期）</li>
<li>SESSION_COOKIE_DOMAIN 默认是none，设置为某个主机名可以启用跨域cookie。</li>
<li>SESSION_COOKIE_SECURE 布尔值，默认为False，设置为True表示只允许HTTPS下使用session</li>
<li>SESSION_EXPIRE_AT_BROWSER_CLOSE 布尔值，默认为False，设置为True表示浏览器关闭就失效</li>
<li>SESSION_SAVE_EVERY_REQUEST 布尔值，默认为False，设置为True表示每次HTTP请求都会更新session，其中的过期时间相关设置也会一起更新。该项可以考虑修改成True。</li>
</ul>
<p>详细内容当然还是要去看django的<a href="https://docs.djangoproject.com/en/2.1/ref/settings/#sessions" target="_blank">session 文档</a>。</p>
<p>这里特别要提一下的就是session的过期控制。在之前做两个项目的时候应该也会注意到，当我登录之后关闭页面的时候，下次再打开页面，依然处于登录状态，这就是因为session保存了登录状态。</p>
<p><code>SESSION_EXPIRE_AT_BROWSER_CLOSE</code>默认为False，如果设置为True，则 <code>SESSION_COOKIE_AGE</code>中的设置不起作用。</p>
<p>在需要延长session过期的情况下，可以使用<code>request.session.set_expiry()</code>设置过期时间。</p>

<h3 id="c7-2-4"><span class="title">2.4</span>在session中存储购物车数据</h3>
<p>存储购物车数据的关键有两个：一是确定存储内容，二是确定存储的方式。从前边session的介绍来看，存储方法打算采用JSON格式，而存储内容是：</p>
<ul>
<li>商品的id字段数据</li>
<li>商品的数量</li>
<li>商品的单位价格</li>
</ul>
<p>这里有个问题是，商品的价格会变化。这里为了简便，我们在将商品加入购物车的同时存储当时商品的价格，如果商品价格之后再变动，也不去管了。（当然这和普通的电商网站是有区别的）</p>
<p>然后我们需要来实现购物车的功能，在这之前需要更细致的分析一下业务逻辑：</p>
<ol>
<li>先检查session中是否存在购物车键，如果存在说明当前用户已经使用了购物车，如果不存在，就新建一个购物车键。</li>
<li>用户每次HTTP请求，都要重复第一步。</li>
<li>之后根据用户提交的操作，向购物车内添加或者删除数据。</li>
</ol>
<p>下边来实现功能。先到settings.py里新增一行：</p>
<pre>CART_SESSION_ID = 'cart'</pre>
<p>这就是我们的购物车键名称，由于session对于每个用户都通过中间件管理，所以可以在所有用户的session里都使用统一的这个名称。</p>
<p>然后新建一个应用专门来控制购物车，启动新应用 cart，然后加入到settings.py中。在cart应用目录下新建cart.py然后编写：</p>
<pre>
from decimal import Decimal
from django.conf import settings
from shop.models import Product


class Cart(object):
def __init__(self):
"""
Initialize the cart.
"""
self.session = request.session
cart = self.session.get(settings.CART_SESSION_ID)
if not cart:
cart = self.session[settings.CART_SESSION_ID] = {}
self.cart =cart
</pre>
<p>这里先编写了一个用来管理cart的类，考虑到每个用户都会有session，可以编写一个类，对应每个用户就实例化一个管理类。目前这个类只编写了初始化函数，里边的逻辑是判断request中是否有cart键，有就取过来，没有就新建一个空白键cart。</p>
<p>初始化了cart之后，下一步就是对cart进行修改。我们打算把商品ID作为键名，将数量和价格作为对应的值。这样可以保证不会重复添加相同的商品，同一个商品只会有一个唯一的键。</p>
<p>继续编写Cart类里的修改购物车功能：</p>
<pre>
class Cart(object):

def add(self, product, quantity=1, update_quantity=False):
"""
向购物车中增加商品或者更新购物车中的数量
:param product: Product实例对象
:param quantity: 增加商品的数量，为整数，默认为1
:param update_quantity: False 表示在原有数量上增加，True表示覆盖原有数量
:return: None
"""

product_id = str(product.id)
if product_id not in self.cart:
self.cart[product_id] = {'quantity': 0, 'price': str(product.price)}
if update_quantity:
self.cart[product_id]['quantity'] = quantity
else:
self.cart[product_id]['quantity'] += quantity
self.save()

def save(self):
# 设置session.modified的值为True，中间件在看到这个属性的时候，就会保存session
self.session.modified = True
</pre>
<p>新增了add和save两个方法。add的功能在注释里已经基本写清楚了，具有设置新数量或增加数量的功能。对于每个session，建立一个cart键，然后其中的套一个product_id键，然后又有两个键price和quantity。一共是三层字典嵌套。</p>

<p>还需要编写从购物车中去掉商品的方法，逻辑比较简单，判断要删除的东西存在于购物车里，就删掉：</p>
<pre>
class Cart:

def remove(self, product):
"""
从购物车中删除商品
:param product: 要删除的Product实例
:return: None
"""
product_id = str(product.id)
if product_id in self.cart:
del self.cart[product_id]
self.save()
</pre>
<p>在后边展示购物车的界面中，很容易就想到需要遍历购物车内的所有商品。因此现在先写一个__iter()__方法，生成迭代器，供将for循环使用。</p>
<pre>
class Cart:

def __iter__(self):
"""
迭代所有购物车内的商品
:return: 迭代器对象
"""
product_ids = self.cart.keys()
products = Product.objects.filter(id__in=product_ids)
cart = self.cart.copy()
for product in products:
cart[str(product.id)]['product'] = product

for item in cart.values():
item['price'] = Decimal(item['price'])
item['total_price'] = item['price'] * item['quantity']
yield item
</pre>
<p>这段代码的逻辑是：取到所有购物车内商品的QuerySet，然后对购物车对象进行了一个浅拷贝。浅拷贝之后的局部变量cart的第一级键不会再变化，但是其中嵌套的字典依然可以变化。原来我们购物车的结构是<code>{'cart': {'product_id': {'quantity': quantity, 'price': price}}}</code>，并且里边都是字符串。但是现在需要迭代其中的商品，就不能简单的返回字符串。</p>
<p>在浅拷贝之后，给这个购物车新增加了product键对应Product实例。</p>
<p>之后用临时变量item返回每个对象的内容，把item键price的值设置为Decimal类型，然后新增了一个总价字段，最后用yield返回每个item。此时每个item的结构是这样的：<code>{'quantity': quantity, 'price': new_price, 'product': product, 'total_price': total_price}</code>，可以想象，未来通过for循环遍历的时候，只需要将这几个键的内容取出来就可以了。</p>
<p>考虑到购物车还需要显示其中一共有几件商品，因此再写一个__len__()方法，以让我们的类可以通过内置方法len来显示长度，实现逻辑就是遍历所有购物车内商品的quantity然后求和：</p>
<pre>
class Cart:

def __len__(self):
"""
购物车内一共有几种商品
:return: INT
"""
return sum(item['quantity'] for item in self.cart.values())
</pre>
<p>与这个方法相同的思路，再编写一个计算总价的方法：</p>
<pre>
class Cart:
def get_total_price(self):
return sum(Decimal(item['price']*item['quantity']) for item in self.cart.values())
</pre>
<p>最后，再编写一个清空购物车的功能。</p>
<pre>
class Cart:

def clear(self):
del self.session[settings.CART_SESSION_ID]
self.save()
</pre>
<p>这样就编写完了这个类。这里的知识其实和session没有很大的关系，主要还是Python中编写类的特殊方法的知识。</p>
<p style="color: red;">这里还要提一下的是，原书的代码定义Cart类的时候是 <code>class Cart(object):</code>可能是作者为了兼容Python2的代码。这里没有按照原书的代码，而是统一按照Python3的新式类方法来编写。</p>

<h3 id="c7-2-5"><span class="title">2.4</span>创建购物车视图</h3>
<p>建立完了管理购物车的类之后，就可以来编写视图了。购物车还记得最开始说类似一个小数据库，所以功能不外乎增删改查。视图的作用，就是将用户前端的增删改查动作获取到，然后调用购物车类来进行增删改查。</p>
<p>针对购物车类的功能，显然我们需要编写3个视图函数：</p>
<ul>
<li>一个视图函数用来增加或者更新购物车内的商品和数量（增和改）</li>
<li>一个视图删除购物车内的商品（删）</li>
<li>一个视图显示购物车内的详细内容和总价（查）</li>
</ul>
<p>现在就来编写这三个视图。首先是增加和更新商品的视图。</p>
<p>为了把商品增加到购物车，除了具体商品的实例肯定在页面中获取了之外，还必须要让用户选择增加的数量。因此先到cart应用中建立form.py，在其中编写一个表单类：</p>
<pre>
from django import forms

PRODUCT_QUANTITY_CHOICES = [(i, str(i)) for i in range(1, 21)]


class CartAddProductForm(forms.Form):
quantity = forms.TypedChoiceField(choices=PRODUCT_QUANTITY_CHOICES, coerce=int)
update = forms.BooleanField(required=False, initial=False, widget=forms.HiddenInput)

</pre>
<p>这个表单包括两个字段，第一个字段是给用户进行选择数量，这里我们通过choices限定了用户选择的数量为1-20，使用了coerce=int表示将该字段的数据转换成整型。coerce参数只能使用在<a href="https://docs.djangoproject.com/en/2.1/ref/forms/fields/#typedchoicefield" target="_blank">TypedChoiceField</a>和<a
    href="https://docs.djangoproject.com/en/2.1/ref/forms/fields/#typedmultiplechoicefield" target="_blank">TypedMultipleChoiceField</a>上。</p>
<p>第二个字段update，用于确认用户是增加数量还是覆盖原来的数量。如果为True，则覆盖，如果为False则增加，这里用了HiddeInput就不想给用户看了。</p>
<p>有了表单以后来建立视图，编写cart应用中的views.py：</p>
<pre>
from django.shortcuts import render, redirect, get_object_or_404
from django.views.decorators.http import require_POST
from shop.models import Product
from .cart import Cart
from .form import CartAddProductForm


@require_POST
def cart_add(request, product_id):
# 实例化购物车对象
cart = Cart(request)
# 取得当前商品
product = get_object_or_404(Product, id=product_id)
# 取得POST表单对象
form = CartAddProductForm(request.POST)
# 如果表单验证通过，调用cart类的add方法然后跳转到购物车详情页面
if form.is_valid():
cd = form.cleaned_data
cart.add(product=product, quantity=cd['quantity'], update_quantity=cd['update'])
return redirect('cart:cart_detail')
</pre>
<p>业务逻辑已经写在了注释里，这个视图的功能非常类似京东的商品详情页面，点击加入购物车的按钮，之后会跳转到另外一个界面，可以返回商品页或者查看购物车，这里我们就直接跳转到了购物车详情页。</p>
<p>再来编写删除商品的视图：</p>
<pre>
def cart_remove(request, product_id):
cart = Cart(request)
product = get_object_or_404(Product, id=product_id)
cart.remove(product)
return redirect('cart:cart_detail')
</pre>
<p>删除方法很简单，继续来编写展示视图：</p>
<pre>
def cart_detail(request):
cart = Cart(request)
return render(request, 'cart/detail.html', {'cart': cart})
</pre>
<p>视图都编写好了之后，在cart应用里新建urls.py：</p>
<pre>
from django.urls import path
from . import views

app_name = 'cart'
urlpatterns = [
path('', views.cart_detail, name='cart_detail'),
path('add/&lt;int:product_id>/', views.cart_add, name='cart_add'),
path('remove/&lt;int:product_id>/', views.cart_remove, name='cart_remove'),
]
</pre>
<p>在项目的一级路由内增加一条，将cart路径转发到cart应用的二级路由里：</p>
<pre>
path('cart/', include('cart.urls', namespace='cart')),
</pre>
<p>注意这一条路由需要增加在shop路径之前，因为shop路径被配置成默认路径，如果放在shop下边，则永远无法被匹配到。路由配置的时候，越严格的匹配越要往上放，最后用最宽泛的路径接着。</p>

<h3><b>建立购物车相关模板</b></h3>
<p>回想一下之前建立的base.html，其中为购物车留出了一行。此外，增加购物车的按钮应该出现在每个商品的详情页中，最后还要单独编写一个购物车清单页面。</p>
<p>建立：cart/templates/cart/detail.html：</p>
<pre>
{% extends 'shop/base.html' %}

{% load static %}

{% block title %}
Your shopping cart
{% endblock %}

{% block content %}
&lt;h1>Your shopping cart&lt;/h1>
&lt;table class="cart">
&lt;thead>
&lt;tr>
&lt;th>Image&lt;/th>
&lt;th>Product&lt;/th>
&lt;th>Quantity&lt;/th>
&lt;th>Remove&lt;/th>
&lt;th>Unit price&lt;/th>
&lt;th>Price&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
{% for item in cart %}
{% with product=item.product %}
&lt;tr>
    &lt;td>
        &lt;a href="{{ product.get_absolute_url }}">
            &lt;img src="
                    {% if product.image %}{{ product.image.url }}{% else %}{% static 'img/no_image.png' %}{% endif %}"
                 alt="">
        &lt;/a>
    &lt;/td>
    &lt;td>{{ product.name }}&lt;/td>
    &lt;td>{{ item.quantity }}&lt;/td>
    &lt;td>
        &lt;a href="{% url 'cart:cart_remove' product.id %}">Remove&lt;/a>
    &lt;/td>
    &lt;td class="num">${{ item.price }}&lt;/td>
    &lt;td class="num">${{ item.total_price }}&lt;/td>
&lt;/tr>
{% endwith %}
{% endfor %}

&lt;tr class="total">
&lt;td>total&lt;/td>
&lt;td colspan="4">&lt;/td>
&lt;td class="num">${{ cart.get_total_price }}&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p class="text-right">
&lt;a href="{% url 'shop:product_list' %}" class="button light">Continue shopping&lt;/a>
&lt;a href="#" class="button">Checkout&lt;/a>
&lt;/p>
{% endblock %}
</pre>
<p>虽然模板很长，但是逻辑很清晰，使用了一个表格展示购物车的内容。表头固定，表内的每一行通过迭代购物车中的每个item，展示对应的字段内容。还留出了删除该商品的链接。最后在表格底部展示购物车总价。</p>
<p>加入购物车的功能如前所述，需要修改商品详情页，注意我们为加入购物车建立了一个表单，所以先要修改product_detail视图函数：</p>
<pre>
def product_detail(request, id, slug):
product = get_object_or_404(Product, id=id, slug=slug, available=True)
cart_product_form = CartAddProductForm()
return render(request, 'shop/product/detail.html', {'product': product, 'cart_product_form': cart_product_form})
</pre>
<p>修改后的视图函数就把表单对象传到了模板中，再来修改shop/templates/shop/product/detail.html模板增加相关内容：</p>
<pre>
{#在 &lt;p class="price">${{ product.price }}&lt;/p> 这行后追加#}
&lt;form action="{% url 'cart:cart_add' product.id %}" method="post">
{{ cart_product_form }}
{% csrf_token %}
&lt;input type="submit" value="Add to cart">
&lt;/form>
</pre>
<p>然后启动站点来实验一下相关功能，可以看到商品详情页内增加了新的功能：</p>
<img src="http://img.conyli.cc/django2/C07-05.jpg" alt="">
<p>点击增加到购物车之后，进入了购物车界面：</p>
<img src="http://img.conyli.cc/django2/C07-06.jpg" alt="">

<h3><b>修改购物车中商品的数量</b></h3>
<p>读者有过电商网站购物经验的话，就会知道我们的购物车很明显缺少一个功能，就是购物车页面修改商品的数量。这种修改与将商品加入购物车不同，修改的结果直接就是商品的最终数量。所以Cart.add方法里也提供了覆盖原来数量的功能。</p>
<p>需要实现这个功能，只需要在购物车详情视图和模板中做一个小修改即可，先来编辑cart应用里的cart_detail视图：</p>
<pre>
def cart_detail(request):
cart = Cart(request)
for item in cart:
item['update_quantity_form'] = CartAddProductForm(initial={'quantity': item['quantity'], 'update': True})
return render(request, 'cart/detail.html', {'cart': cart})
</pre>
<p>这个视图在每次进入购物车详情页面的时候，给所有的商品添加了一个键值对，值是initial里的数据初始化的CartAddProductForm实例。</p>
<p>为什么要这么做呢，其实就是为了区分当前的修改是来自购物车详情页面的，这里的修改都需要覆盖原数量。</p>
<p>回忆一下操作的流程。CartAddProductForm的update被我们以隐藏的形式埋在了商品详情页面里。其默认为空，提交给add方法的update参数就是空。所以在送到add方法里的时候，会将当前数量加上去。那么我们只需要在进入购物车详情页的时候，修改表单里的update字段的值为True就可以了。</p>
<p>然后修改网页上展示的那个quantity的部分，打开cart/templates/cart/detaii.html：</p>
<pre>
{#修改&lt;td>{{ item.quantity }}&lt;/td>这一行#}
&lt;td>
&lt;form action="{% url 'cart:cart_add' product.id %}" method="post">
{{ item.update_quantity_form.quantity }}
{{ item.update_quantity_form.update }}
&lt;input type="submit" value="Update">
{% csrf_token %}
&lt;/form>
&lt;/td>
</pre>
<p>修改之后，就是将原来的数字部分改成了一个表单，表单的数据就是用视图函数中初始化的表单类的数据填充的，这样隐藏的update字段的值变成了True，只要是从这个页面提交给cart_add视图的表单，都会覆盖原来数量。</p>
<p>之后启动站点，到购物车详情页来，可以看到如下所示：</p>
<img src="http://img.conyli.cc/django2/C07-07.jpg" alt="">

<h3><b>为购物车构建上下文处理器</b></h3>
<p>所谓上下文，就是程序的外部变量集合。我们注意到这个时候还有一个地方的功能没有实现，那就是网站首页的购物车那一栏，依然没有变化。每个网站都会有一些可能需要在每个页面都使用的数据，这些东西就类似于全局变量。就像在前几章在模板里使用过的request.user，request.messages以及本章的request.session，并不需要我们给模板传入request对象和user对象等，直接在所有的视图和模板中都可以使用。</p>
<p>回忆一下前博客项目对base.html显示最多评论的文章是使用了自定义的template tag；社交网站的base.html的顶部，为了知道当前的内容以便应用CSS样式，每个视图都传了一个section变量。这都是一种技巧。更通用的做法就像社交网站base.html的消息部分，直接采用request.messages变量。</p>
<p>django中的上下文管理器，就是能够接受一个request请求对象作为参数，然后给request对象附加一个键值对的函数。当默认启动一个项目的时候，settings.py中的 TEMPLATES 设置中的<code>conetext_processors</code>部分，就是给模板附加上下文的上下文管理器，有这么几个：</p>
<ul>
<li>django.template.context_processors.debug：这个上下文管理器附加了布尔类型的debug变量，以及sql_queries变量，表示请求中执行的SQL查询</li>
<li>django.template.context_processors.request：这个上下文管理器设置了request变量</li>
<li>django.contrib.auth.context_processors.auth：这个上下文管理器设置了user变量</li>
<li>django.contrib.messages.context_processors.messages：这个上下文管理器设置了messages变量</li>
</ul>
<p>除此之外，django还启用了django.template.context_processors.csrf来防止跨站请求攻击。这个组件没有写在settings.py里，但是是强制启用的，无法进行设置和关闭。有关所有上下文管理器的详情请参见<a
    href="https://docs.djangoproject.com/en/2.1/ref/templates/api/#built-in-template-context-processors" target="_blank">官方文档</a>。</p>
<p>现在我们就来设置一个自定义上下文管理器，原来每个视图都将cart变量传递给模板，以后就可以在所有模板内直接使用cart变量。</p>
<p>在cart应用内新建一个context_processors.py文件，同视图，模板以及其他内容一样，django内的程序可以写在应用内的任何地方，但为了结构良好，还是分离出各个组件比较好：</p>
<pre>
from .cart import Cart
def cart(request):
return {'mycart': Cart(request)}
</pre>
<p>有点简单是不是，django规定的上下文处理器，就是一个函数，接受request请求作为参数，然后返回一个键值对。键的名称就是未来在模板中可以使用的request.XXX名称。</p>
<p>之后在settings.py里将我们的自定义上下文管理器加到TEMPLATES设置中：</p>
<pre>
TEMPLATES = [
{
'BACKEND': 'django.template.backends.django.DjangoTemplates',
'DIRS': [os.path.join(BASE_DIR, 'templates')]
,
'APP_DIRS': True,
'OPTIONS': {
'context_processors': [
......
<b>'cart.context_processors.cart'</b>
],
},
},
]
</pre>
<p>定义了上下文管理器之后，只要一个模板被渲染，上下文管理器就会执行然后附加上变量名。值得注意的是，上下文管理器并不是必须的。如果上下文的内容涉及到数据库查询等比较耗时的操作，或者上下文管理器中的变量，并不是所有页面都需要，则一般情况下首先考虑的是使用<b>自定义模板变量</b>。否则会极大的影响网站的效率。</p>
<p>有了mycart变量之后，由于只是给request附加了初始化的Cart实例，所以对其他视图没有任何影响，base.html由于没有视图直接控制，就使用上下文变量比较方便，修改base.html：</p>
<pre>
{#修改&lt;div class="cart">的内容#}

&lt;div class="cart">
{% with total_items=mycart|length %}
{% if mycart|length > 0 %}
Your cart:
&lt;a href="{% url 'cart:cart_detail' %}">{{ total_items }} items{{ total_items|pluralize }},
${{ mycart.get_total_price }}
&lt;/a>
{% else %}
Your cart is empty.
{% endif %}
{% endwith %}
&lt;/div>
</pre>
<p>启动站点，可以发现现在购物车栏正常工作了：</p>
<img src="http://img.conyli.cc/django2/C07-08.jpg" alt="">
<p style="color: red">这里需要说明一下的是：原书的上下文管理器的代码是：</p>
<pre>
from .cart import Cart
def cart(request):
return {'<b style="color:red">cart</b>': Cart(request)}
</pre>
<p style="color:red">由于所有的用到购物车界面的模板都继承了base.html，视图函数都传入了名叫cart的变量，base.html里也使用cart名称的变量，作者在这里把全局变量和传入的变量设置成一样，没有很好的体现出区分效果。故将上下文管理器和base.html中的变量名cart都修改为mycart，以体现出mycart和cart是两个来自于不同地方的变量。</p>


<h2><b>用户订单功能</b></h2>
<p>在刚才的购物车详情页面中，有一个Checkout 结账功能，目前还无法使用。现在要来制作用户订单功能。</p>
<p>在每个购物车生成订单的时候，需要把订单的数据保存到数据库中。一个订单应该包含用户以及要购买的商品等信息。</p>
<p>建立一个新的应用orders并在settings.py里配置好。我们将用这个应用来处理订单相关的功能。</p>

<h3><b>建立订单数据模型</b></h3>
<p>首先还是思考一下，在点击Checkout按钮的时候，购物车页面上有什么数据？主要的数据就是cart变量代表的购物车数据对象。光有商品还不够，肯定还需要知道当前的用户是谁。其实还有一个重要的数据就是该订单是否已经支付。Order模型就是围绕这些数据建立的，编辑models.py：</p>
<pre>
from django.db import models
from shop.models import Product


class Order(models.Model):
first_name = models.CharField(max_length=50)
last_name = models.CharField(max_length=50)
email = models.EmailField()
address = models.CharField(max_length=250)
postal_code = models.CharField(max_length=20)
city = models.CharField(max_length=100)
created = models.DateTimeField(auto_now_add=True)
updated = models.DateTimeField(auto_now=True)
paid = models.BooleanField(default=False)

class Meta:
ordering = ('-created',)

def __str__(self):
return 'Order {}'.format(self.id)

def get_total_cost(self):
return sum(item.get_cost() for item in self.items.all())


class OrderItem(models.Model):
order = models.ForeignKey(Order, related_name='items', on_delete=models.CASCADE)
product = models.ForeignKey(Product, related_name='order_items', on_delete=models.CASCADE)
price = models.DecimalField(max_digits=10, decimal_places=2)
quantity = models.PositiveIntegerField(default=1)

def __str__(self):
return '{}'.format(self.id)

def get_cost(self):
return self.price * self.quantity
</pre>
<p>建立了两个模型Order和OrderItem，Order模型用来存储订单号，和订单相关的用户信息，以及一个是否支付的布尔字段。稍后将在支付系统中将使用该字段。还定义了一个获得总金额的方法，以便方便的知道订单的总额以便支付。</p>
<p>OrderItem两个外键分别连接到商品表和订单表，然后还存储了生成订单时候的价格和数量。由于价格是会变化的，所以在订单中只存储生成订单时候的价格用于计算总付款金额。然后定义了一个get_cost方法。这个类看起来类似多对多关系的的中间表，但实际上发挥的是一对一的功能。因为无需再到Product中去查询金额。</p>
<p>执行过makemigrations和migrate之后，将这两个类加入到管理后台中，编辑orders/admin.py：</p>
<pre>
from django.contrib import admin
from .models import Order, OrderItem


class OrderItemInline(admin.TabularInline):
model = OrderItem
raw_id_fields = ['product']


@admin.register(Order)
class OrderAdmin(admin.ModelAdmin):
list_display = ['id', 'first_name', 'last_name', 'email',
    'address', 'postal_code', 'city', 'paid',
    'created', 'updated']
list_filter = ['paid', 'created', 'updated']
inlines = [OrderItemInline]
</pre>
<p>这次注册模型又引入了一些新的形式和字段。对OrderItem类继承了admin.TabularInline类，然后在OrderAdmin类中使用了inlines参数指定了OrderItemInline类。意思是将OrderItem类以内联（行显示）的状态包含在Order类中，显示在同一页。</p>
<p>这种注册模型的方式仅影响展示形式，不会影响models.py中定义的两个类之间的关系。</p>
<p>启动站点到 http://127.0.0.1:8000/admin/orders/order/add/ 可以看到如下的页面，更好的展示了订单与其中包含的商品之间的关系：</p>
<img src="http://img.conyli.cc/django2/C07-09.jpg" alt="">

<h3><b>建立订单视图和模板</b></h3>
<p>用过电商网站的读者应该知道，比如京东从购物车页面点击“去结算”按钮，会进入到一个结算页，供用户填写信息，选择地址，支付方式和配送方式等。这个页面实际上也是填写一个表单，再点提交才会真正生成订单让你付款。</p>
<p>类似的，我们生成一个新订单有如下步骤：</p>
<ol>
<li>给用户提供一个表单供填写</li>
<li>根据用户填写的内容生成一个新Order类实例，然后将Cart中的商品放入OrderItem实例中并与Order实例建立外键关系</li>
<li>清理全部购物车内容，然后重定向用户到一个成功的页面或者进行其他动作。</li>
</ol>
<p>首先就利用内置表单功能建立订单表单，在orders应用中新建forms.py：</p>
<pre>
from django import forms
from .models import Order


class OrderCreateForm(forms.ModelForm):
class Meta:
model = Order
fields = ['first_name', 'last_name', 'email', 'address', 'postal_code', 'city']
</pre>
<p>采用内置的方法建立了包含这些字段的表单，现在针对这个表单要建立视图来控制表单，编辑orders应用中的views.py：</p>
<pre>
from django.shortcuts import render
from .models import OrderItem
from .forms import OrderCreateForm
from cart.cart import Cart


def order_create(request):
cart = Cart(request)
if request.method == "POST":
form = OrderCreateForm(request.POST)
# 表单验证通过就对购物车内每一条记录生成OrderItem中对应的一条记录
if form.is_valid():
order = form.save()
for item in cart:
OrderItem.objects.create(order=order, product=item['product'], price=item['price'],
                         quantity=item['quantity'])
# 成功生成OrderItem之后清除购物车
cart.clear()
return render(request, 'orders/order/created.html', {'order': order})

else:
form = OrderCreateForm()
return render(request, 'orders/order/create.html', {'cart': cart, 'form': form})
</pre>
<p>整体的逻辑是，如果是POST请求而且表单验证通过，对购物车里每一个商品都在OrderItem表里生成对应的一行记录，之后删除购物车，并且不再像模板内cart变量了。（当然我们有上下文管理器，还是可以用）。</p>
<p>如果是POST请求但表单验证失败，返回原来表单数据，如果是GET请求，返回空白表单及购物车数据。注意，这里两个分支渲染的是两个不同的页面 create.html和 created.html。</p>
<p>视图有了下一步是配路由，先在orders应用里建立urls.py作为二级路由：</p>
<pre>
from django.urls import path
from . import views

app_name = 'orders'

urlpatterns = [
path('create/', views.order_create, name='order_create'),
]

</pre>
<p>再配置主路由myshop/urls.py：</p>
<pre>
path('orders/',include('orders.urls', namespace='orders')),
</pre>
<p>注意这一行也要在转发到shop.urls那一行之前。</p>
<p>既然现在我们有了视图函数，那就可以修改购物车详情页cart\templates\cart\detail.html的CHECKOUT按钮的链接了：</p>
<pre>
&lt;a href="{% url 'orders:order_create' %}" class="button">Checkout&lt;/a>
</pre>
<p>最后是来建立模板。在orders应用下建立templates/orders/order目录，然后在order目录内建立create.html和created.html，先来编辑create.html：</p>
<pre>
{% extends 'shop/base.html' %}

{% block title %}
Checkout
{% endblock %}

{% block content %}
&lt;h1>Checkout&lt;/h1>

&lt;div class="order-info">
&lt;h3>Your order&lt;/h3>
&lt;ul>
{% for item in cart %}
&lt;li>
{{ item.quantity }} x {{ item.product.name }}
&lt;span>${{ item.total_price }}&lt;/span>
&lt;/li>
{% endfor %}
&lt;/ul>
&lt;p>Total: ${{ cart.get_total_price }}&lt;/p>
&lt;/div>

&lt;form action="." method="post" class="order-form" novalidate>
{{ form.as_p }}
&lt;p>&lt;input type="submit" value="Place order">&lt;/p>
{% csrf_token %}
&lt;/form>
{% endblock %}
</pre>
<p>模板内容比较简单，展示购物车内的商品和总价，之后下边提供空白表单供填写。再来编辑created.html</p>
<pre>
{% extends 'shop/base.html' %}

{% block title %}
Thank you
{% endblock %}

{% block content %}
&lt;h1>Thank you&lt;/h1>
&lt;p>Your order has been successfully completed. Your order number is &lt;strong>{{ order.id }}&lt;/strong>.&lt;/p>
{% endblock %}
</pre>
<p>created.html就是一个成功页面。现在运行站点，加入一些商品到购物车中，然后点击checkout，可以看到如下页面：</p>
<img src="http://img.conyli.cc/django2/C07-10.jpg" alt="">
<p>填写表单然后点击Place order，可以看到成功页面：</p>
<img src="http://img.conyli.cc/django2/C07-11.jpg" alt="">
<p>至此就做完了订单功能。</p>


<h2><b>使用Celery异步发送订单邮件给用户</b></h2>
<p>如果读者有过在Amazon上购物的经历，可以知道很多电商网站在用户成功下订单后，会发送一封电子邮件到用户的邮箱，内容一般是告诉用户订单的内容。</p>
<p>为了发送邮件，先来了解一下异步的程序。我们在视图函数中所作的所有事情，都会影响视图函数的响应时间，在视图函数完成操作之前，某些URL或者网站内容可能不可用。对于比较耗时间的操作，这样可能会导致请求失败，或者需要用户重试。举个例子：很多视频分享网站允许用户上传视频，上传之后，服务器还需要花时间进行转码，如果在这个时候用户访问该视频，显然不可能允许用户直接访问资源地址，会导致访问失败。常用的做法是设置一个重试功能，在转码完成之前用户想要查看自己上传的视频，就返回一个请求说该视频尚未处理完毕。</p>
<p>如果我们在视图中调用发送邮件的程序，SMTP服务器很可能会连接失败或者花费比较长的时间，如果直接在视图函数内编写，则视图函数会阻塞到邮件发送完毕才会执行下一步程序。会导致页面的响应非常慢。如果能让发邮件和返回页面响应异步的进行，那么页面的响应速度就可以提高很多。读者可以回忆一下，我们在社交网站的用户验证部分建立了发送邮件重置密码的功能，点击发送到返回成功发送的速度是不是相比其他页面要慢很多。</p>
<p>Celery是一个分布式任务队列，采取异步的方式同时执行大量的操作，支持实施操作和计划任务，可以方便的批量创建异步任务并且执行。Celery的文档在<a href="http://docs.celeryproject.org/en/latest/index.html" target="_blank">http://docs.celeryproject.org/en/latest/index.html</a>。</p>

<h3><b>安装Celery</b></h3>
<p>在django 中使用 Celery 需要在Python 中安装Celery模块：</p>
<pre>
pip install celery==4.1.0
</pre>
<p>作者推荐的是4.1版，在本文发布的时候celery最新版为4.2.1，之前已经体验过了taggit的低版本和Django 2.1冲突的问题，所以既然安装了Django 2.1，笔者没有按照作者推荐，而是安装celery的最新版。如果发现问题，踩坑捉虫的过程也是很有意思的。</p>
<p>Celery需要一个消息代理程序来处理外界的请求，这个代理把要处理的请求发送到Celery worker，也就是实际处理任务的模块。所以还需要安装一个消息代理程序：</p>

<h3><b>安装RabbitMQ</b></h3>
<p>Celery的消息代理程序有很多选择，Redis数据库也可以作为Celery的消息代理程序。这里我们使用RabbitMQ，因为它是Celery官方推荐的消息代理程序。</p>
<p>关于Celery，RabbitMQ以及Redis的相关内容，可以看<a href="https://www.jianshu.com/p/1840035cb510" target="_blank">这里</a>的一篇文章。</p>
<p>RabbitMQ的下载地址：<a href="https://www.rabbitmq.com/download.html" target="_blank">https://www.rabbitmq.com/download.html</a>。</p>
<p>Linux下安装RabbitMQ：</p>
<pre>
apt-get install rabbitmq
</pre>
<p>之后启动服务：</p>
<pre>
rabbitmq-server
</pre>
<p>之后会看到：</p>
<pre>
Starting broker... completed with 10 plugins.
</pre>
就说明RabbitMQ已经就绪，等待接受消息。
<p>Windows 下安装 RabbitMQ，必须先安装<a href="https://www.erlang.org/downloads" target="_blank">Erlong OPT平台</a>，然后安装从官网下载回来的RabbitMQ windows installer。</p>
<p>然后把Erlong安装目录下的bin目录和RabbitMQ安装目录下的sbin目录设置到PATH中。之后安装参见<a href="https://blog.csdn.net/tjcyjd/article/details/77150893" target="_blank">这里</a>。</p>

<h3><b>将Celery 加入到项目中</b></h3>
<p>确定好了本机的RabbitMQ服务正常运行之后，需要在django 中使用celery，在myshop/myshop/目录下新建一个文件celery.py：</p>
<pre>
import os
from celery import Celery


# 导入django的环境
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myshop.settings')


app = Celery('myshop')

app.config_from_object('django.conf:settings', namespace='CELERY')
app.autodiscover_tasks()

</pre>
<p>这里的程序主要是和Celery相关，而不是django，解释如下：</p>
<ul>
<li>首先导入django 的环境变量，为Celery命令行创造环境。如果读者使用Pycharm开发django项目，Pycharm中启动Python console，实际上已经默认执行了该语句，作用就是将当前命令行环境配置成django项目。</li>
<li>然后实例化了一个Celery对象</li>
<li>调用Celery对象的.config_from_object方法，从我们的设置文件中读取设置。Celery除了可以通过实例化简单使用外，还支持设置文件进行设置，从而比较健壮的使用Celery。同时提供了一个命名为CELERY，说明我们的设置文件里，所有和CELERY相关的设置都以"CELERY"开头。</li>
<li>最后我们调用.autodiscover_tasks()，让Celery自动发现所有的异步任务。Celery会在每个INSTALLED_APPS中列出的应用中寻找task.py文件，在里边寻找定义好的异步任务然后执行。</li>
</ul>
<p>还需要在项目的__init__.py文件中导入celery模块，以让django运行的时候celery就运行，编辑myshop/__inti__.py：</p>
<pre>
import celery

from .celery import app as celery_app

</pre>
<p>CELERY_ALWAYS_EAGER设置可以让celery在本地以同步的方式直接执行任务，而不会去把任务加到队列中。这常用来进行测试或者检查Celery的配置是否正确。</p>
<p>之后就可以来编辑异步任务了。</p>

<h3><b>编写需要异步处理的任务</b></h3>
<p>我们准备在用户提交订单的时候异步发送邮件。一般的做法是在应用目录下建立一个模块（task.py)用于专门的异步任务，在orders应用下建立task.py：</p>
<pre>
from celery import task
from django.core.mail import send_mail
from .models import Order


@task
def order_created(order_id):
"""
当一个订单创建完成后发送邮件通知给用户
:param order_id: 订单编号
:return: mail_sent
"""

order = Order.objects.get(id=order_id)
subject = 'Order {}'.format(order.id)
message = 'Dear {},\n\nYou have successfully placed an order. Your order id is {}.'.format(order.first_name,
                                                                               order_id)
mail_sent = send_mail(subject, message, 'lee0709@vip.sina.com', [order.email])
print(mail_sent, type(mail_sent))
return mail_sent
</pre>
<p>使用celery模块中的@task 装饰器装饰想成为异步任务的函数。推荐只给异步函数传入ID，让其去检索数据库。拼接好标题和正文后发送邮件。</p>
<p>在之前已经学习过如何发送邮件，如果没有SMTP服务器，在settings.py里将邮件配置为打印到控制台上：</p>
<pre>
EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'
</pre>
<p>这里是将发送邮件这类耗时比较大的功能配置到为异步功能，在实际应用中，除了耗时比较大的功能之外，还可以将其他容易失败需要重试的功能，无论耗时长短，都可以设置为异步任务。</p>
<p>设置好了异步任务之后，还需要修改原来的视图order_created，以便在订单完成的时候，调用该异步函数。修改后的视图如下：</p>
<pre>
from django.shortcuts import render
from .models import OrderItem
from .forms import OrderCreateForm
from cart.cart import Cart
from .task import order_created


def order_create(request):
cart = Cart(request)
if request.method == "POST":
form = OrderCreateForm(request.POST)
# 表单验证通过就对购物车内每一条记录生成OrderItem中对应的一条记录
if form.is_valid():
order = form.save()
for item in cart:
OrderItem.objects.create(order=order, product=item['product'], price=item['price'],
                         quantity=item['quantity'])
# 成功生成OrderItem之后清除购物车
cart.clear()
<b># 成功完成订单后调用异步任务发送邮件</b>
<b>order_created.delay(order.id)</b>
return render(request, 'orders/order/created.html', {'order': order})

else:
form = OrderCreateForm()
return render(request, 'orders/order/create.html', {'cart': cart, 'form': form})
</pre>
<p>被装饰过的异步函数对象有一个delay方法，将order.id作为参数，order.id就会被传给我们自行编写的函数。当每次有用户完成订单的时候，这个异步的函数对象就会被加入到队列，然后等着被worker执行。</p>
<p>启动另外一个shell（必须是导入了当前环境的命令行窗口，比如Pycharm中启动的terminal），启动Celery worker，让工人等待干活：</p>
<pre>celery -A myshop worker -l info</pre>
<p>之后可以看到类似下边的输出，表示Celery worker 已经就绪：</p>
<pre>
[2018-09-28 20:51:13,985: INFO/MainProcess] Connected to amqp://guest:**@127.0.0.1:5672//
[2018-09-28 20:51:13,999: INFO/MainProcess] mingle: searching for neighbors
[2018-09-28 20:51:15,040: INFO/MainProcess] mingle: all alone
[2018-09-28 20:51:15,086: INFO/MainProcess] pidbox: Connected to amqp://guest:**@127.0.0.1:5672//.
[2018-09-28 20:42:04,641: INFO/SpawnPoolWorker-6] child process 16896 calling self.run()
[2018-09-28 20:42:04,641: INFO/SpawnPoolWorker-1] child process 15652 calling self.run()
[2018-09-28 20:42:04,673: INFO/SpawnPoolWorker-8] child process 18224 calling self.run()
[2018-09-28 20:42:05,225: WARNING/MainProcess] django.py:200: UserWarning: Using settings.DEBUG leads to a memory leak, never use this setting in p
roduction environments!
warnings.warn('Using settings.DEBUG leads to a memory leak, never '
[2018-09-28 20:42:05,227: INFO/MainProcess] celery@Notebook ready.
</pre>
<p>可以看到Celery默认去连接了RabbitMQ的服务，然后显示使用guest:账号连接成功；之后提醒我们在生成环境下不要使用DEBUG，会导致内存泄露。</p>
<p>现在我们启动django站点，然后去实际提交一个订单。看到terminal窗口中出现：</p>
<pre>
[2018-09-28 20:51:37,255: INFO/MainProcess] Received task: orders.task.order_created[d9734042-2423-45cc-8109-a901f938bec4]
[2018-09-28 20:51:42,895: WARNING/MainProcess] 1
[2018-09-28 20:51:42,896: WARNING/MainProcess] &lt;class 'int'>
[2018-09-28 20:51:42,896: INFO/MainProcess] Task orders.task.order_created[d9734042-2423-45cc-8109-a901f938bec4] succeeded in 5.64100000000326s: 1
</pre>
<p>检查邮件发现成功的完成了任务。如果注意看RabbitMQ的监控窗口，可以看到RabbitMQ的DeliverMessage会出现我们的任务，Queues中可以看到有一个Celery的运行中队列</p>
<p style="color: red">注意，在发送邮件的时候，有可能出现错误信息如下：</p>
<pre>
<b style="color: red">not enough values to unpack (expected 3, got 0)</b>
</pre>
<p style="color: red">这是因为Celery 4.x 在win10版本下运行都有这个问题，解决方案为：先安装Python的 eventlet模块：</p>
<pre>
<b style="color: red">pip install eventlet</b>
</pre>
<p style="color: red">然后在启动Celery worker的时候，加上参数 -P eventlet，命令行如下：</p>
<pre>
<b style="color: red">celery -A myshop worker -l info -P eventlet</b>
</pre>
<p style="color: red">即可解决该错误。在linux下应该不会发生该错误。参考Celery项目在 Github 上的问题：<a href="https://github.com/celery/celery/issues/4081" target="_blank">Unable to run tasks under Windows #4081</a></p>

<h3><b>使用Flower图形化模块监控Celery</b></h3>
<p>如果想要监控异步任务的执行情况，可以安装Python 的FLower模块：</p>
<pre>
pip install flower==0.9.2
</pre>
<p>Flower库好像是本书中第二个从作者成书到翻译之间没有更新版本的库。Flower的项目地址是<a href="https://flower.readthedocs.io/" target="_blank">https://flower.readthedocs.io/</a></p>
<p>之后在新的终端窗口（如果是Pycharm，点terminal左上角的+）输入：</p>
<pre>
celery -A myshop flower
</pre>
<p>之后在浏览器中打开http://localhost:5555/dashboard，即可看到图形化监控的Celery情况：</p>
<img src="http://img.conyli.cc/django2/C07-12.jpg" alt="">

<h1><b>总结</b></h1>
<p>这一章里主要完成了四个任务，分别是建立基础的商品品类和明细展示页面，通过session建立购物车系统，建立提交订单系统，以及以发送邮件为例子介绍了在django 中使用异步任务。</p>
<p>主要的新知识有：</p>
<ul>
<li>为字段建立联合索引，使用meta类的index_together属性</li>
<li>注册管理后台的list_edit属性，可以直接在列表页修改字段</li>
<li>session模块的中间件与类似字典方式的使用</li>
<li>自定义类管理购物车和类似的小型数据</li>
<li>建立自定义上下文处理器，为项目内所有表单增加全局变量</li>
<li>上下文管理器与自定义template tag的取舍</li>
<li>注册管理后台的Inline模式，外键关联的表格显示在一页内的做法</li>
<li>Celery与RabbitMQ在linux和windows下的配置</li>
<li>Django内使用Celery的方法与异步功能的编写</li>
<li>Win10中Celery运行错误的解决方法</li>
<li>Flower模块图形化监控Celery状态</li>
</ul>


</body>
</html>